- [计算机网络和因特网](#1)
    - [什么是因特网](#1-1)
    - [网络边缘](#1-2)
    - [网络核心](#1-3)
    - [分组交换网中的时延，丢包和吞吐量](#1-4)
    - [协议层次及其服务模型](#1-5)
    - [面对攻击的网络](#1-6)
- [应用层](#2)
    - [应用层协议原理](#2-1)
    - [Web和HTTP](#2-2)
    - [因特网中的电子邮件](#2-3)
    - [DNS：因特网的目录服务](#2-4)
    - [P2P文件分发](#2-5)
    - [视频流和内容分发网](#2-6)
    - [套接字编程:生成网络应用](#2-7)
- [运输层](#3)
    - [概述和运输层服务](#3-1)
    - [多路复用和多路分解](#3-2)
    - [无连接运输:UDP](#3-3)
    - [可靠数据传输原理](#3-4)
    - [面向连接的运输：TCP](#3-5)

<h1 id='1'>计算机网络和因特网</h1>

<h2 id='1-1'>什么是因特网</h2>

> 1. 描述具体构成 (基本硬件和软件)
 
端系统通过通信链路和分组交换机连接到一起，最著名的两种分组交换机为路由器(用于网络核心)和链路层交换机(用于接入网中)

端系统通过因特网服务提供商（ISP）接入因特网

TCP(传输控制协议)，IP(网际协议)

> 2. 为分布式应用提供服务的联网基础设施

what分布式应用程序: 涉及多个相互交换数据的端系统的应用程序

套接字接口,该接口规定了运行在一个端系统上的程序请求因特尔基础设施向运行在另一个端系统上的特定目的地程序发生数据的方式

> 协议

what： 定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发生和/或接收一条报文或其他事件所采取的动作

<h2 id='1-2'>网络边缘</h2>

主机被分为客户和服务器
### 接入网
what接入网： 将端系统物理连接到其边缘路由器的网络

1. 家庭接入
```
DSL(数字用户线)

因特网服务提供商（ISP）： 本地电话接入的本地电话公司
调制解调器： 现有电话线(双绞铜线)
交换数据的对象： 位于电话公司的本机中心局中的数字用户线接入复用器(DSLAM)
交换过程： 数字信号 -> ( DSL调制解调器 )-> 高频音（模拟信号） -> (电话线传输到本地中心局) -> 在DSLAM处转换回数字信号
速度：12Mbps下行 1.8Mbps上行 (1999)  55Mbps下行 15Mbps上行 (2006) 
局限： 速度慢，距离限制
```
```
电缆因特网接入,混合光纤同轴系统

ISP： 提供有线电视的公司
调制解调器: 电缆调制解调器
交换数据的对象: 电缆调制解调器端接系统(CMTS，公司处)
特征： 共享广播媒体(每个家庭都通过上行信道向头部传输 ，都通过下行信道接收数据 所以可能网速可能较慢且需要分布式多路访问协议来协调传输和避免碰撞)
速度：42.8Mbps 下行 30.7Mbps 上行
```
```
光纤到户(FTTH)

what: 从本地中心局直接到家庭提供一条光纤路径
分类： 主动光纤网络(AON，本质是交换因特网)   被动光纤网络(PON)

PON：
过程： 每个家庭具有一个光纤网络端接器(ONT)，由光纤连接到临近分配器，分配器把他们集结到一根共享的光纤，在连接到本地电话和公司的中心局的光纤线路端接器(OLT)，通过OLT进行光信号到电信号的转化，通过公司路由器和因特网相连。从OLT发送到分配器的分组在分配器处复制
速度:用户平均下行速度20Mbps

```
```
拨号 和 卫星
```

2. 企业(和家庭)接入 以太网和wifi 

使用局域网(LAN)将端系统连接到边缘路由器

3. 广域和无线接入 ： 3G 和 LTE

### 物理媒体

what： 在因特网中使用的传输媒体

分类： 导引型媒体（固体媒体） 和 非导引型媒体(空气或外层空间)

<h2 id='1-3'>网络核心</h2>

what: 互联因特网端系统的分组交换机和链路构成的网状网络

通过网络链路和交换机移动数据有两个基本方法：电路交换，分组交换

### 分组交换 : 按需分配


`分组`： 为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块

分组通过通信链路和分组交换机传送，每个分组以等于该链路的最大传输速率的速度传输通过通信链路。

`存储转发传输`： 交换机能够开始向输出链路传输该分组的第一个比特前，必须接收到整个分组

所以N条速率均为R的链路组成的路径，端到端时延为 N*L/R

`排队时延`：分组交换机有输出缓存（输出队列） ，有正在传输的分组，其他分组必须在输出缓存中等待

`分组丢失(丢包)`: 缓存空间有限，一个到达的分组可能发现缓存都被其他等待传输的分组占满了，所以就会丢失

> 路由器如何选择分组向哪条链路转发 ？  `转发表`和`路由选择协议`

每台路由有转发表，用于将目的地址(或目的地址一部分)映射成输出链路，因特网有路由选择协议,自动设置转发表

### 电路交换

在电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源(缓存，链路传输资源)，因为预留了宽带所以发送方能以恒定速率向接收方传送数据

端到端的电路传输时间与链路数量无关

链路中的电路通过频分复用(FDM) 或 时分复用 (TDM) 实现

FDM: 每条电路连续获得部分带宽   TDM: 每条电路在时隙中周期性(周期为一帧)获得全部带宽

#### 网络的网络

等级化网络 ： 多层的ISP 

增加存在点(POP)： what： 提供商网络中的一台或多台路由器群组，客户ISP 通过 提供商POP 连接 提供商ISP ，客户ISP通过第三方电信提供商租用高速链路将他的路由器之一直接链接到该POP的一台路由器 

客户ISP可以`多宿`，即选择多个提供商ISP，使一个提供商出现意外后仍能提供服务，为了减少费用(因为ISP支付给供应商的费用反映他通过供应商交换的通信流量)  客户ISP会选择和临近同一等级ISP `对等` ，使他们流量直接连接而不通过上游ISP传输 ，所以第三方公司创建 因特网交换点(IXP)，IXP是一个汇合点，多个ISP能在此对等

内容提供商网络：如谷歌 内容提供商与较低层ISP对等或者在IXP处与他们对等，尝试创建自己的网络，绕过第一层ISP，不过有些接入ISP只能通过第一层连接 所以 内容提供商也与第一层连接 不过仅仅为这些ISP交换的流量付费。

<h2 id='1-4'>分组交换网中的时延，丢包和吞吐量</h2>

#### 分组交换网中的时延概念

分类： 节点处理时延， 排队时延，传输时延，传播时延 

传输时延和传播时延的比较： 传输时延：路由器推出分组所需时间(取决于分组长度和链路传输速率)      传播时延：一个比特从一台路由器传输到另一台路由器所需时间(两台路由器之间距离的函数)

#### 排队延时和丢包

分组到达队列的平均速率(a) ， 传输速率(R)即从队列中推出比特的速率  ， 分组长度 L比特 那么 La/R被称为`流量强度`, 流量强度不能大于1 ，因为不然排队时延会趋于无穷大(比特到达速率超过传输速率)

丢包： 链路有着有限容量，满时，新队列到达时将会被丢弃

#### 端到端时延

Traceroute程序

#### 端系统，应用程序和其他时延

媒体分组化时延： IP语音中(VoIP) ，发送方在向因特网传递分组之前必须首先用编码的数字化语音填充一个分组。这种填充一个分组的时间称之位分组化时延。

#### 计算机网络中的吞吐量

瞬间吞吐量： 接收文件的速率

吞吐量不仅取决于沿着路径的传输速率，也取决与干扰流量(例如 有多个用户同时下载)

<h2 id='1-5'>协议层次及其服务模型</h2>

#### 协议分层

每层通过在该层执行某些动作或使用直接下层的服务来来提供服务

协议栈： 各层的所有协议 ：（由下到上） 1. 物理层 2. 链路层 3. 网络层 4. 运输层 5. 应用层
```
1. 应用层 ： 网络应用程序及他们的应用层协议存留的地方

HTTP (web文档的请求和帮助) ，
SMTP (电子邮件报文的传输) ，
FTP (端系统之间文件的传送)
DNS (域名系统)

报文 ： 位于应用层的信息分组
```
```
2. 运输层 : 在应用程序端点之间传送应用层报文

有两种运输协议
TCP (提供面向连接的服务)
1. 应用层报文向目的地的确保传递和流量控制 2. 长报文划分为短报文，提供拥塞控制系统(当网络拥塞时，源抑制其传输速率)

UDP (提供无连接服务)
不提供不必要的服务

报文段：运输层的分组
```
```
3. 网络层 : 负责将数据报的网络层分组从一台主机移动到另一台主机

运输层协议(TCP或UDP)向网络层递交传输层 报文段 和 目的地址

IP (网络协议)，定义了数据报的各个字段 以及 端系统和路由器如何作用与这些字段
路由选择协议

数据报: 网络层分组
```
```
4. 链路层：为将分组从一个节点(主机或路由器)移动到下一个节点，网络层必须依靠链路层的服务，在这个过程中 网络层将受到来自每个不同链路层协议的不同服务

网络层将数据下传个链路层 链路层沿着路径将数据传递给下一个节点 ，在下个节点 链路层将数据报上传个网络层

以太网,wifi和电缆接入网的DOCSIS协议 

帧：链路层分组
```
```
5. 物理层 ： 将帧中的一个个比特从一个节点移动到下个节点

与该链路的实际传输媒体相关联
```
OSI 模型
```
相比因特网协议栈多了 表示层 和 会话层

```

#### 封装

链路层交换机： 链路层和物理层

路由器 : 网络层 链路层，物理层   (能识别IP)

一个分组具有两种类型的字段 :首部字段和有效载荷字段 ,首部字段是在该层添加的 ，有效载荷字段一般来自于上一层的分组

<h2 id='1-6'>面对攻击的网络</h2>

#### 将有害程序放入计算机中

`病毒`: 需要某种形式的用户交互来感染用户设备的恶意软件(如 电子邮件附件)

`蠕虫`：无需任意明显用户交互就能进入设备的恶意软件

#### 攻击服务器和网络基础设施

`拒绝服务攻击(DoS)` : 弱点攻击(攻击易受攻击的应用程序或操作系统)  带宽洪泛(发送大量分组，如 分布式DoS)   连接洪泛 (在目标主机 创建大量半开或全开的TCP连接)

#### 嗅探分组

分组嗅探器 ： 记录每个流经的分组副本的被动接收器

#### 伪装成信任对象

<h1 id='2'>应用层</h2>

<h2 id='2-1'>应用层协议原理</h2>

### 网络应用程序体系结构

应用程序体系结构 ：1.  客户 - 服务器 体系结构   2. P2P体系 结构
```
客户 - 服务器 体系结构  (例如 搜索引擎 因特网商务 社交网络 基于web的电子邮件)
what: 有一个总是打开的服务器 服务于来自许多其他称为客户的主机的请求
特点 ： 1. 客户之间不直接通信 2. 该服务器具有固定的周知的地址
优点: 安全 性能高 可靠 IP固定能访问
缺点：对服务器性能要求高  服务提供商要支付互联和宽带费用 
```
```
P2P 体系结构 (例如 文件共享 对等方协助下载器 因特网电话和视频会议)
what： 对位于数据中心的专用服务器有着最小程度依赖
特点：  应用程序在客户之间直接通信  服务器被用于追踪用户Ip地址 ，但用户到用户的报文在用户主机间直接传输
优点：自拓展性 (每个用户为系统增加服务能力) ,对服务器要求小，成本低
缺点:面临安全性 性能 和可靠性的挑战
```
### 进程通信

what:两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信

#### 客户与服务器进程

在一对进程的通信会话中，发起通信的进程被标记为客户 ，在会话开始时等待联系的被标记为服务器

#### 进程与计算机网络之间的接口

进程通过`套接字`的软件接口向网络发送报文和向网络接收报文

what套接字: 应用程序和网络之间的 `应用程序编程接口(API)` 

应用程序对运输层的控制仅限于 1. 选择运输层协议 2. 能设定几个运输层参数(如最大缓存和最大报文段长度)

#### 进程寻址

标识接收进程 ： 1. 主机地址 (IP地址)   2. 在目的主机指定接收进程的标识符 (端口号)

### 可提供应用程序使用的运输服务

运输层协议为应用程序提供的服务 : 1. 可靠数据传输 2. 吞吐量 3. 定时 4. 安全性

#### 可靠数据传输

能保证进程传输数据无差错到达另一进程

#### 吞吐量

what： 发送进程能够向接收进程交付比特的速率

带宽敏感应用 ，对吞吐量高要求 (如 多媒体应用 视频电话)   弹性应用 (如 电子邮件等)

#### `定时`

时延

#### `安全性`

加密数据

### `因特网提供的运输服务`

UDP和TCP

#### `TCP`

提供 面向连接服务和 可靠数据传输

面向连接服务 : 在应用层报文传递之前 ，先进行握手(客户和服务器相互交换运输层控制信息)，握手后 TCP连接 建立
，双方进程可以同时进行报文收发 ，接收报文发送时，连接拆除

可靠数据传输： 没有字节的丢失和冗余

拥塞控制机制 

用SSL(TCP的加强)来提高安全性 ，在应用层实现

#### `UDP`

仅提供最小服务 (因特网电话 因为能容忍某些丢失但对速度有要求)

#### 因特网运输协议所不提供的服务

吞吐量 和 定时保证 

### 应用层协议

应用层协议定义 ： 1. 交换的报文类型 2. 各种报文类型的语法 3. 字段的语义 4. 确定一个进程何时已经如何发送报文，对该报文响应的规则

### 本书涉及的网络应用

Web ， 文件传输 ， 电子邮件 ， 目录服务(DNS):网络名字到网络地址的转换 ， 流式视频 ， P2P

<h2 id='2-2'>Web和HTTP</h2>

### HTTP概况

what: 超文本传输协议 

实现: 客服程序和服务器程序 通过交换HTTP报文进行会话 ，HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式

HTTP使用TCP作为传输协议，HTTP客户首先发起与服务器的TCP连接 ,连接成功后 ( 客户 通过套接字接口发生HTTP报文 报文进入TCP控制 发送到服务器 套接字接口 然后服务器接收 )

HTTP 是`无状态协议`： 不保存用户信息

### 非持续连接和持续连接

客户发送一系列请求， 每个请求/响应由单独的 TCP 连接发送  (非持续连接) ,由相同TCP发送 (持续连接)

#### 采用非持续连接的HTTP

例如 从服务器向客户传送以一个包含 1个HTML基本文件和10个JPEG图形 ，该HTML他的URL为
http:// www.aa.com/bb.index

1. HTTP客户进程向端口号80 发送一个到服务器 www.aa.com 的TCP连接

2. HTTP客户经它的套接字向服务器发送一个HTTP请求报文，该报文包含路径/bb.index

3. HTTP服务器经他的套接字接收该报文请求，从他的存储器检索/bb.index ，在一个HTTP响应报文中封装对象，并通过器套接字向客户发送响应报文

4. HTTP服务器通知TCP 断开TCP连接 (实际断开直到TCP确认用户接收到响应报文为止)

5. HTTP客户接收响应报文，TCP连接关闭，客户从响应报文中提取该文件，并得到对10个JPEG图形的引用

6. 对每个引用的JPEG文件重复前4 个步骤

在本例子中 ，用户请求该Web页面 要建立 11个TCP连接(可能为 串行 或 并行)

往返时间(RTT)： 指一个短分组从客户到服务器然在返回客户所花费的时间

用户点击超链接时的响应时间: 浏览器建立和Web服务器的TCP连接，这涉及三次握手 (用户向服务器发送一个小TCP报文段， 服务器用小TCP报文段做出确认和响应 ，用户向服务器返回确认 ) ，三次握手前两个部分占用一个RTT ，第三部分确认过程中向该TCP连接发送一个HTTP请求报文，一旦报文达到服务器，服务器就在该TCP上发送HTML文件，占用一个RTT
所以总时间为 两个 RTT 和 传输HTML的时间

缺点: 1. 必须为每一个请求对象建立和维护一个全新的TCP连接 (给Web服务器带来负担)  2. 每一个对象都要经受两倍的RTT 的交付时延

#### 采用连续连接的HTTP

服务器发送响应后保持该TCP连接打开, 直到一定时间间隔未被使用然后关闭

### HTTP报文格式

#### 请求报文

例如
```
GET /somedir/page.html HTTP/1.1 //请求行 (方法字段  URL字段  HTTP版本字段 )
Host: www.someschool.edu // 首部行 ，指明的 对象所在主机
Connection: close  // 要不要使用持续连接 否
User-agent: Mozilla/5.0 //  向服务器发送请求的浏览器类型 ： 这里是火狐
Accept-language: fr // 要求返回的版本类型   法语版本
```
方法字段 : 1. GET (浏览器请求一个对象) 2. POST (用表单生成的请求报文，在 实体体中包括用户在表单中的输入值) 3. HEAD (类型GET，但不返回请求对象，常用于开发 调试与跟踪) 4. PUT (允许用户上传对象到指定的Web服务器上指定的路径) 5. DELETE (删除Web服务器上的对象)

#### 响应报文

类似
```
HTTP/1.1 200 ok  // 状态栏 (协议版本字段  状态码 相应状态信息)
// 6个首部行
Connection: close  // 发送完报文后关闭TCP连接
Date: Tue,  18 Aug 2015 15:44:04 GMT // 首部行指示服务器尝试并发送该响应报文的日期和时间(服务器从他的
                                文件系统中检索到该对象，并将该对象插入响应报文，并发送该响应报文时间)
Server: Apache/2.2.3(CentOS) // 指示该报文是一台Apache Web服务器产生的
Last-Modified: Tue,  18 Aug 2015 15:11:03 GMT // 对象创建或最后修改日期和时间
Content-Length: 6821  // 被发送对象中的字节数
Content-Type: text/html // 实体体中的对象时 HTML文本

(data data data data data ...)  //实体体，报文主要内容包含所请求对象本身
```
### 用户和服务器的交互 : cookie

cookie ： 允许站点对用户进行追踪

4个部件： 1. 在HTTP响应报文中的一个cookie首部行 2. 在HTTP请求报文中的一个cookie首部行 3. 在用户端系统中保留一个cookie 由用户浏览器进行管理 4. 位于Web站点后端数据库中 

### Web缓存

Web缓存器也称代理服务器，能代表初始服务器来满足HTTP请求的网络实体

存在Web缓存器时，客户请求对象，会先检查Web服务器有无该对象，若有直接返回 ，若无 ，请求初始服务器，对象会先传输给Web缓存器且在本地存储副本，在传输给客户

优点：能有效降低时延且成本低

通过内容分发网络(CDN) ，web缓存器发挥越来越重要作用

### 条件GET方法

尽管web缓存能降低用户感受到的响应时间，不过有个问题，web缓存器中可能存的对象副本是陈旧的。

HTTP的条件GET，允许web缓存器证明它存的是最新的

条件GET格式： 1. 请求报文使用GET方法 2. 请求报文中包含一个"If-Modified-Since:"

因为对象的属性中有一个是 最后修改时间，当客户请求web缓存器时 ，web缓存器会先向初始服务器发送一个条件GET，
如果最后修改时间相同则代表最新 ，否则从初始服务器下载对象，然后保存副本
```
条件GET

GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu 
If-Modified-Since: Tue,  18 Aug 2015 15:11:03 
```

<h2 id='2-3'>因特网中的电子邮件</h2>

3个主要部分 ： 用户代理(例如 微软的Outlook )  邮件服务器   简单邮件传输协议(SMTP)

每个接收方或发送方在邮件服务器上有个邮箱

发送过程 ： 发送方的用户代理 到  发送方邮件服务器 通过STMP 传输到接收方邮件服务器 在分发给 接收方的邮箱中

### SMTP

what: 是因特网电子邮件中的主要应用层协议 ，使用TCP传输

限制所有邮件报文的体部分，只能采用简单的7 bit ASCII 表示，即再用SMTP传输邮件之前 ，需要将二进制多媒体数据编码成ASCII码 ，并且在使用SMTP后要求将相应ASCII码解码还原成多媒体数据。而HTTP不需要将多媒体转换为ASCII码

SMTP一般不使用中间邮件服务器发送邮件，如果接收方邮件服务器没有开机，那么报文会保留在发送方邮件服务器上，并等待新的尝试.在几天后仍不成功 删除该报文并通知 发送方

握手过程 ： 1. HELO  2. MAIL FROM 3. RCPT TO 4. DATA (以 . 结束) 5. QUIT 

连续连接直到所有邮件发送完毕只会才发送QUIT，关闭TCP

####  与HTTP的对比

1. 传送文件 ： HTTP 从 web服务器 到 Web客户  ， SMTP是从 邮件服务器 到 邮件服务器

2. 都使用持续连接，HTTP主要为拉协议 ，用户从该服务器拉取信息 ， SMTP为推协议 ，发送邮件服务器把文件推向邮件服务器

3. SMTP要求每个报文使用 7比特 ASCII ，HTTP 无限制

4. 如何处理既包含文本又包含图形  HTTP ：把每个对象封装到它的HTTP报文中  SMTP： 把所以报文对象都放在一个报文中

#### 邮件报文格式

必须包含  From ： 首部行      To ： 首部行

#### 邮件访问协议

因为SMTP为推协议 ，所以接收用户不是通过SMTP获取接收邮件服务器上的报文，而是通过 第三方的邮局协议(POP3) ,因特网邮件访问协议( IMAP )和 HTTP协议

> POP3 ： 1. 特许 2. 事务处理  3. 更新

特许(用户代理发送用户名和口令以鉴别用户)

事务处理 (用户代理取回报文  ，还可以 对报文做删除标记   取消报文删除标记  获取邮件统计信息 )
```
list ：获取邮件服务器所有储存的报文的长度
retr : 获取 报文  (如 retr 1)
dele ：删除报文 (如  dele 1)
quit : 退出

会话过程中POP3服务器 不包含状态信息，结束后会保留一些信息 ，如哪些用户报文被标记删除
```
跟新 ： (客户发出quit命令后 结束该POP3会话 ，删除被标记为删除的报文)

> IMAP(因特网邮件访问协议)

特点: 1. IMAP服务器维护IMAP会话的用户状态信息(例如 文件夹的名字以及哪些报文和哪些文件夹相关联)
     2. 具有允许用户代理获取报文某些部分的命令 (例如 获取报文的报文首部，或报文内容的一小部分)，在网速低的时候很有用

操作 ：IMAP 服务器把每个报文 和一个文件夹联系起来  ，一开始存放于INBOX文件夹。 1. 阅读 2. 删除 3. 创建文件夹以及移动邮件 4. 查找邮件

> 基于Web 的电子邮件

用户代理是浏览器 ，即 用户和远程邮箱之间的通信依赖于HTTP (从浏览器发送到他的邮件服务器，依靠HTTP)，但是，邮件服务器和邮件服务器之间还是通过SMTP

<h2 id='2-4'>DNS：因特网的目录服务</h2>

IP地址标识主机 ，主机名也标识主机

### DNS提供的服务

域名系统(DNS)： 进行主机名到IP地址转换的目录

what ： 1. 一个由分层DNS服务器实现的分布式数据库 2. 一个使得主机能够查询分布式数据库的应用层协议

DNS服务器通常运行BIND软件的UNIX机器，DNS协议运行于UDP协议 使用 53 号端口

HTTP请求 URL为 www.aa.com/a.html 时，该主机用户必须获得www.aa.com的IP地址，步骤如下
```
1. 浏览器从URL抽离 www.aa.com 将其发送给DNS应用的客户端
2. DNS应用的客户端向DNS服务器发送包含该主机名的请求
3. DNS客户最终会收到一份回答报文，其中还有对应的IP地址，DNS发送给浏览器
4. 浏览器接收到该IP地址以后，向该IP地址的80端口的HTTP服务器进程发起一个TCP连接
```
DNS服务
```
1. 主机名到IP的转换
2. 主机别名 (一台主机可能有多个别名 ，有一个规范主机名) ，DNS获取规范主机名和相应IP
3. 邮件服务器别名，MX
4. 负载分配 ( 一个IP地址集合 可能与一个规范主机名相联系 )，当用户访问主机时 ，DNS选择冗余的主机进行访问，而不是选择繁忙主机
```
#### DNS的工作原理

DNS由分布于全球的大量DNS服务器和定义了DNS服务器与查询主机通信方式的应用层协议组成

特点 ：1. 分布式，层次数据库 2. DNS缓存

> 分层式，层次数据库 

分3层 ： 1. 根DNS服务器 2. 顶级域DNS服务器（ TLD ） (例如 com DNS服务器 edu DNS服务器) 3. 权威DNS服务器 (例如 amazon.com DNS 服务器)

另外重要的DNS服务器是 本地DNS服务器 ( 每个ISP有一个本地DNS服务器 )，用户发送DNS请求时 是发往本地DNS服务器，起着代理作用

请求主机到本地DNS服务器是递归查询 ，本地DNS服务器到其他都是迭代查询 ( 获得IP后之间返回给本地DNS )
```
1.请求主机请求某个主机名 到本地DNS     2. 本地DNS到根DNS    3. 根返回顶级域IP到本地    4. 本地到顶级域     5. 顶级域返回 权威IP到本地      6. 本地到权威       7. 权威返回请求的主机名对应IP到本地     8. 本地返回对应IP到请求主机
```
> DNS缓存

每次其他DNS返回DNS回答(包括某主机名到IP的映射)都被本地DNS服务器记录 过一段时间后会丢弃该缓存数据。因为缓存，除了少数DNS查询以为，根服务器被绕过了

### DNS记录和报文

DNS服务器存储了资源记录(RR),RR 提供主机名到IP的映射。

what (RR) ：记录了一个包含( Name, Value, Type, TTL)的四元组

TTL代表交易记录应当从缓存中删除的时间 ，Name和Value取决于 Type
```
Type = A ,Name = 主机名 ，Value = 该主机名对应IP 
例如(忽视TTL)(relay1.bar.foo.com , 145.37.93.126 , A)
Type = NS ,Name = 个域 ，Value = 如何获得该域中IP的权威DNS服务器
( foo.com, dns.foo.com ,NS )
Type = CNAME ,Name = 主机名 ，Value = 该主机名对应规范主机名
( foo.com ,relay1.bar.foo.com, CNAME)
Type = MX ,Name = 邮件服务器的主机名 ，Value = 该邮件服务器对应的规范主机名
( foo.com , mail.bar.foo.com , MX)

获得邮件服务器规范地址请求MX ，获得其他服务器规范地址请求 CNAME
```
一台DNS服务器是某个特定主机的权威DNS服务器，则包含该主机名的A记录 ，如果不是 ，那么会包含一条NS (包含 主机名的域 和 该域的权威DNS服务器 ) 和一条A记录 ( 包含该NS记录对应的DNS服务器的IP )  （虽然不是该特定主机的权威DNS，但是如果已经请求过 ，缓存中也会有包含用于该主机的A记录）

例如 (umass.edu , dns.umass.edu ,NS)    ( dns.umass.edu, 128.119.40.111, A)

`DNS报文 `
```
1. 首部区域(12字节)(标识符 标志 问题数 回答RR数  权威RR数 附加RR数) 标识符  用于标识该查询，复制到回答报文中 ，用于两个的匹配    标志： 若干标志(例如 是查询还是回答 是不是权威服务器等)

2. 问题区域 (包括 查询的名字(被查询的主机名) 和 类型字段(例如 A 或者 与邮件服务器相连的MX) ) 

3. 回答区域 ： 对最初请求的名字的RR  ，可能包含多条RR，因为一个主机名可以对应多个IP ,可能包含 CNAME (规范主机名)

4. 权威区域 ： 其他权威服务器的记录

5. 附加区域 ： 其他有帮助的记录 (例如 请求的是MX类型 ，那么回答区域提供邮件主机的规范主机名 ，附加区存放一个类型A记录，记录提供该规范主机名对应IP )
```
nslookup程序

`在DNS数据库中插入记录`

注册登记机构,例如注册 wwww.aaa.com 登记时提供基本和辅助DNS服务器 dns1.aaa.con 和IP地址1.1.1.1 ，该注册登记机构将一个 NS 和 A 记录出入到 TLD com 中 对应用于 aaa.com的基本权威服务器 插入 (aaa.com, dns1.aaa.con, NS) (dns1.aaa.com , 1.1.1.1 , A),我们还得确保用于Web服务器的A记录和用于邮件服务器的MX记录被输入到权威DNS服务器中

<h2 id='2-5'>P2P文件分发</h2>

服务器 发送给对等方文件的文件块，对等方接收以后也开始分发

扩展性 ： 对等方不仅是文件块的接收者也是文件块的重新分发者

### BitTorrent

`洪流` :参与一个特定文件分发的所有对等方的集合

洪流中对等方彼此下载等长度的文件块 (典型为 256 kb) ，用户可以随时退出洪流

洪流的基础设施节点： 追踪器 。 当对等方加入洪流时，它向追踪器注册主机，并周期性通知追踪器主机仍在洪流中。 当一个新的对等方加入洪流 ，追踪器向其发送 对等方的一个子集，新对等方向子集中的对等方创建TCP连接

> 1. 它应该向邻居( 已建立TCP连接 )请求哪些块

最稀缺优先： 针对它没有的块 在它的邻居中副本数量最少的块  ( 均衡每个块在洪流中的副本数量 )

> 2. 他向哪些向他请求的邻居发送块

它(设为 A )根据当前能以最高速率向他提供数据的邻居，给予优先权 。 确定4个最高速率的邻居集合，称为 疏通 ，每过10s 可能会修改这个集合 。另外，每过30s ，随机选择另一个邻居(设为 B )，与其交换( 允许其得到块 ) ，如果双方都满足此交换(双方速率高)，将其也放入 集合， 直到某一个对等方发现了一个更好的伴侣为止。 除了这5个对等方，A 对 其他对等方不发送

<h2 id='2-6'>视频流和内容分发网</h2>

可以用比特率来权衡视频质量，流式视频最重要的性能度量是 平均端到端吞吐量

普通HTTP流视频问题：所有用户得到相同编码的视频，而不考虑客户的带宽

经HTTP的动态适应性流( DASH )： 视频编码有几个不同版本，允许客户使用不同的以太网接入速率流式播放具体不同编码速率的视频

使用DASH，每个视频版本都存储在HTTP服务器中，每个有不同的URL。服务器有 告示文件，为每个版本提供URL及其比特率。客户请求告示文件得到不同版本，客户通过HTTP GET请求报文对视频每一块指定一个URL和一个字节范围，一次选择一块。在下载块的同时，客户测量接收宽带并运行一个 速率决定算法 来选择下次请求的块

### 内容分发网( CDN )

what ： 1. 管理分布在多个地理位置上的服务器，在他的服务器中存储视频(和其他类型的Web内容)的副本，并且试图将每个客户请求定向到一个提供最好用户体验的CDN位置

why (创建单一的大规模数据中心的问题)：1、如果客户远离数据中心，那么分组需要跨越许多通信链路经过很多不同ISP ，延迟较高 2. 流行到视频可能经过相同链路发送多次 ，浪费带宽和支付更多费用  3.一个单点故障，就不能分发任何视频流了

种类：有 专用CDN 和 第三方CDN

有两种不同的服务器安置原则 1. `深入` ，通过在遍及全球的接入ISP部署服务器集群来深入ISP的接入网 ，靠近端用户。 (时延低，维护和管理费用高)  2. `邀请做客` ，在少量关键位置(如 IXP，因特网交换点 )建造大集群来邀请到ISP做客 。(维护和管理费用低，延时较高，吞吐量较低)

CDN可以跨集群复制内容。 如果客户向一个没存储某个视频的CDN请求，该CDN会检索该视频(从中心仓库或另一个集群),向用户传送视频同时保留副本，当存储器变满时，删除不经常访问的视频


> 当浏览器检索一个特定的视频时(有URL标识) ，CDN必须截获这个请求以便于 1. 确定此时适合用户该用户的CDN服务器集群 2. 将用户的请求重定向到该集群的某台服务器

CDN利用DNS截获和重定向请求
```
假设 内容提供商NetCinema  雇佣第三方CDN公司 KingCDN 来分发视频 ，在NetCinema 的web网站上，每个视频都被标识为'video'已经该视频独特的标识符 ,例如 http:// video.netcinema.com/6Y7B23V

1. 用户访问位于 NetCinema的Web网站 ，此时用户点击 http:// video.netcinema.com/6Y7B23V ，用户自己主发送对于 video.netcinema.com的DNS请求

2. 用户本地DNS服务器(LDNS) ，将该DNS请求中继到用于NetCinema的权威服务器，该服务器观察到video标识，为了将该DNS请求转移到KingCDN
向LDNS返回一个 KingCDN的主机名，如a1105.kingcdn.com

3. 此时，DNS请求进入KingCDN专用DNS基础设施。 LDNS发送对a1105.kingcdn.com的请求，最终到达KingCDN 的权威DNS (自己的猜测  
该DNS请求被CDN获取，通过集群选择策略，选择最佳CDN集群，将IP传给权威DNS  )，权威DNS向LDNS返回KingCDN内容服务器的IP

4. LDNS向主机转发内容服务CDN节点的IP

5. 客户与该IP的服务器创建直接TCP连接，并发出对视频的 HTTP GET请求，如果服务器使用DASH服务，服务器将首先发送具有URL列表的告示文件

```
集群选择策略：动态将客户定向到CDn某个服务器集群或数据中心的机制。

CDN得知LDNS的IP，为该IP选择合适集群。 方法 1. 地理上最邻近 ( 缺点：忽略时延和可用宽带变化，总是提供相同集群 )  2. 为其集群和LDNS的时延和丢包性执行周期性实时测量 ( 缺点： 许多LDNS被配置为不响应这些探测 )


#### 例子

`Netflix` ： 仅分发视频，所以不需要DNS重定向操作 ，Netflix软件直接告示客户要连接哪一台CDN服务器，且Netflix使用推高速缓存，而不是拉高速缓存， 内容在非高峰时段的预定时间被推入服务器

`YouTube`： 使用专用CDN 已经在几百个IXP和ISP位置安装了服务器集群。使用 拉高速缓存和DNS重定向 ，集群选择策略是使得客户和集群之间RTT(往返时间)最低。没有应用适应性流，需要用户人工选择。为了节省哪些将被重定向或提前终止而浪费的带宽和服务器资源，YouTUbe 在获取视频目标量，使用HTTP字节范围请求来限制传输的数据流

`迅雷看看`： P2P流式视频 ，一个对等方要看一个视频时，它联系一个追踪器，以发现在系统中具有该视频副本的其他对等方。这个请求的对等方则并行的从具有该文件的其他对等方请求该视频的块。不过请求被优先播给那些即将播放的块(而不是稀缺块),以确保连续播放。CDN服务器在流式视频启动阶段起主要作用，当P2P总流量满足视频播放时，该客户将从CDN停止流并仅从对等方获得流 。但如果P2P流量不足，该客户将重新启动CDN连接返回混合CDN-P2P流模式     (确保短启动延迟，于此同时最小的依赖于成本高的基础设施服务器和带宽)

<h2 id='2-7'>套接字编程:生成网络应用</h2>

网络应用： 由客户程序和服务器程序组成，位于两个不同端系统中，运行这两个程序时，创建客户进程和服务器进程，同时他们通过套接字读出和写入数据在彼此之间通信

分类： 1， 由协议标准中定义的操作实现  2. 专用的网络应用

#### UDP套接字编程

使用UDP之前，需要将目的地址附在该分组上(目的地址包括 IP和端口号)。每当我们生成一个套接字时，需要为他分配一个称为端口号的标识符  发送方的源地址(即IP和端口号) 也会附在分组上，不过这个是由底层操作系统实现，不需要UDP代码实现

在客户发送报表之前，服务器必须作为一个进程运行

例如 写一个 客户从键盘读取一行字符向服务器发送，服务器转换为大写后返回的程序

`UDPClient.py`  客户端，他没给自己设定端口号，是操作系统主机分配的
在报文中 系统会自动将客户地址附在分组
```python
from socket import *
serverName = '118.24.197.134' # 服务器端主机号
serverPort = 12000 # 服务器端 端口号
clientSocket = socket(AF_INET,SOCK_DGRAM) # 创建客户的套接字，称为clientSocket，
# AF_INET 为一个地址簇 ，指示底层网络使用 IPv4  SOCK_DGRAM 代表 他是一个UDP套接字
# 我们通过系统为我们指定客户套接字的端口号
message = raw_input('Input lowercase srntence: ')  # 用户输入一行 与提示信息
clientSocket.sendto(message.encode(),(serverName,serverPort)) 
# encode()把字符串变成字节   sendto发送到指定主机的端口号
modifiedMessage, serverAddress = clientSocket.recvfrom(2048)
# recvfrom 从服务器接收返回的数据 ，2048为缓存长度 前一个存数据 后一个存服务器源地址
print(modifiedMessage.decode()) #decode 将字节转换为字符串,然后输出
clientSocket.close() # 关闭
```
`UDPServer.py`  服务器端 在报文中 系统会自动将服务器地址附在分组
```python
from socket import *
serverPort = 12000
serverSocket = socket(AF_INET,SOCK_DGRAM)
serverSocket.bind(('',serverPort)) # 将端口号12000与该服务器的套接字serverSocket相连
print("The server is ready to receive")
while True: # 一直保持 等待连接状态
    message,clientAddress = serverSocket.recvfrom(2048) # 接收数据 和客户源地址
    modifiedMessage = message.decode().upper() # 转换为字符串后转换为大写
    serverSocket.sendto(modifiedMessage.encode(),clientAddress) # 发送回去

```

#### TCP套接字编程

TCP是面向连接的协议，在客户和服务器能够开始发送数据之前，先要握手和创建一个TCP连接。创建TCP连接时，先将客户套接字地址(TP和端口)和服务器套接字地址相连接.连接后，传输数据只要将数据放入TCP连接即可，不需要附上地址

对TCP服务器要求 ： 1. 进程已运行 2. 需要有一个欢迎套接字

客户先通过服务器的欢迎套接字与其进行三次握手，然后服务器会建立一个新的连接套接字，客户与服务器通过连接套接字来进行数据交换

`TCPClient.py`
```python
from socket import *
serverName = '118.24.197.134'
serverPort = 12000
clientSocket = socket(AF_INET,SOCK_STREAM) # SOCK_STREAM代表通过TCP
# 我们仍是通过系统为我们指定客户套接字的端口号
clientSocket.connect((serverName,serverPort)) # 这条代码执行完后，执行三次握手并创建TCP连接
sentence = input('Input lowercase srntence: ')
clientSocket.send(sentence.encode()) # 只需要send 不需要目的地址
modifiedSentence = clientSocket.recv(1024) # 接收
print('From Server: ',modifiedSentence.decode())
clientSocket.close()

```
`TCPServer.py`
```python
from socket import *
serverPort = 12000
serverSocket = socket(AF_INET,SOCK_STREAM)
serverSocket.bind(('',serverPort)) # 绑定套接字和端口号,serverSocket是我们的欢迎套接字
serverSocket.listen(1)  # 让服务器聆听来自客户的TCP连接请求，定义请求连接的最大数为1
print("The server is ready to receive")
while True:
    connectionSocket, addr = serverSocket.accept() 
    # 当客户敲门时，程序为serverSocket调用accept()方法,创建了新的连接套接字，由这个特定用户专用
    #　此时客户与服务器完成握手并connectionSocket建立TCP连接
    sentence = connectionSocket.recv(1024).decode()
    capitalizedSentence = sentence.upper() # 大写
    connectionSocket.send(capitalizedSentence.encode())
    connectionSocket.close()# 关闭connectionSocket套接字

```

<h1 id='3'>运输层</h1>

该层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用(主要为TCP和UDP)

关注问题：1. 将网络层的两个端系统之间交付服务扩展到云在两个不同端系统上应用层进程直接的交付服务 2. 怎样在一种会丢失会损坏数据的媒体上可靠的通信 3. 拥塞控住

<h2 id='3-1'>概述和运输层服务</h2>

### 概述和运输层服务

运输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信**

运输层协议在端系统中实现而不是在路由器中，路由器仅作用于数据报的网络层字段，不检查封装在数据报中的运输层报文段字段

#### 运输层和网络层的关系

网络层提供主机之间的逻辑通信，运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信。(邮政体系)

运输层协议只工作在端系统中，将应用层报文移动到网络层。 运输层协议能提供的服务常常受制于网络层协议的服务模型

即使底层网络层不可靠，但是运输层也能为应用程序提供可靠的数据传输服务和安全性保证

#### 因特网运输层概述

UDP(用户数据报协议)  TCP(传输控制协议)

`网际协议(IP)`的服务模型是 尽力而为交付服务，但他不做任何保证(不确保报文段交付，不保证报文段按序交付，不保证报文段数据完整性),是不可靠服务。

UDP和TCP的将主机交付拓展为进程间交付称为 运输层的多路复用与多路分解

`UDP和TCP 最低限度服务`(也是UDP仅有的服务) ：1. 进程到进程间的数据交付 2. 差错检查( 通过在其报文段首部的 差错检测字段 提供完整性检查)

UDP也是不可靠服务，不保证完整交付 ，TCP是可靠的数据传输，通过 流量控制，序号，确认，定时器来保证数据 正确，按序和完整 ，还提供拥塞控制(防止任何一条TCP占用过多流量)

<h2 id='3-2'>多路复用和多路分解</h2>

运输层是通过`套接字端口`和应用进程传递数据的。

`多路分解` : 将运输层报文段中的数据交付到正确的套接字。 `多路复用`:源主机从不同套接字中收集数据块，为每个数据块封装上首部信息(用于之后的分解)，从而生成报文段，然后将报文段发送给网络层

运输层多层复用要求：1. 套接字有唯一标识符  2. 每个报文段有特殊字符( 源端口号字段和目的端口号 )来指示该报文段所要交付到的套接字

端口号是16比特的数(0 - 65535 )，(0 - 1023) 范围的是周知端口号

### 无连接的多路复用和多路分解(UDP)

一般客户套接字是由运输层自动分配，服务器套接字会指定关联一个特殊端口号
```python
clientSocket = socket(AF_INET,SOCK_DGRAM) # 创建客户的套接字，称为clientSocket，

serverSocket.bind(('',serverPort)) # 将端口号12000与该服务器的套接字serverSocket相连
```

UDP套接字是由一个包含 目的IP地址 和 目的端口号 的`二元组`全面标识的。两个不同的报文段有着相同目的IP地址 和 目的端口号会被定向到相同目的进程

源端口号可以用作返回地址的一部分，服务器向客户返回报文段

### 面向连接的多路复用与多路分解(TCP)

TCP套接字是由一个`四元组`标识( 源IP地址， 源端口号，目的IP地址，目的端口号)，即使是同一条电脑，请求的IP地址和目的端口相同，如果两个请求的源端口号不同也会定向为两个不同TCP

TCP客户发出创建套接字并发出请求，先达到目的 欢迎套接字，然后服务器进程用 四元组 创建新的套接字，TCP连接完成，所有后续到达的报文段如果携带数据和四元组匹配则分配到该套接字

客户接收到的返回数据目的端口号应该已经指向连接套接字而不是欢迎套接字，所以客户以后传输的数据目的端口号应该和连接端口号匹配

#### web服务器和TCP

如今高性能web服务器通常只使用一个进程，但未每个新的客户创建一个具有新连接套接字的新`线程`(线程可以看作是一个轻量级的子进程) 

非持续HTTP：套接字的频繁创建和关闭会严重影响服务器性能

<h2 id='3-3'>无连接运输:UDP</h2>

在发送报文段之前，发送方和接收方的运输层实体之间没有握手，即无连接

`UDP优点` ：1. 关于发送什么数据以及何时发送的应用层控制更为精细。(数据一传给UDP，立刻打包发送且不存在拥塞控制) 2. 无须建立连接(没有建立连接的时延) 3. 无连接状态(UDP服务器不维护连接状态能支持更多客户) 4. 分组首部开销小(TCP报文段20字节首部开销，UDP8字节)

DNS就是运行在UDP上的

UDP也可实现可靠传输例如(谷歌Chrome的QUIC协议)，在应用层协议中实现可靠性

UDP运行多媒体时可能出现的问题： 每个人都看高比特率视频但是都没有拥塞系统，可能会导致路由器的大量分组溢出，UDP发送方和接收方存在高丢包率且，网络拥挤会导致TCP连接的速率也很慢(因为TCP存在拥塞控制，会降低速率)

#### UDP报文段结构

首部(源端口号 目的端口号 长度(首部+数据的字节数) 检验和 ) 和应用数据(报文) 。

首部共8字节，每个两字节。检验和 可以用来检查该报文段是否存在差错

#### 检验和

提供了差错检测功能。检验和是报文段中的所有16比特字的和 对这个和进行反码运算得到的 ( 求和中遇到任何溢出会被回卷(溢出部分加到尾部) )，所以 所有16比特字 和 检验和 的和 为16比特的 1 
```
以 3比特为例子  有两个3比特字为 100 和 100 ，那么得到他们的和为 001  检验和为 110

检验和 和 100 和 100 的和 为 111(回卷后)
```
但是检验和只能只能监测是否出错，不能进行差错恢复 ，一般要么丢弃受损报文段，要么将受损报文段返回给应用程序并提出警告

为什么提供： 因为在既无法确保链路的可靠性，又无法确保内存中的差错检查情况下，如果端到端数据要通过差错检测，UDP必须在端到端基础上正在运输层提供操作,`端到端原则`(某些功能必须基于端到端实现)

<h2 id='3-4'>可靠数据传输原理</h2>

可靠数据传输协议(例如 TCP) : 数据确保到达 数据按序到达 数据完整不丢失

可靠数据传输协议的下层协议可能是不可靠的，例如 TCP的下层协议 IP 不可靠

rdt 代表可靠  udt 代表不可靠

> 上层 通过调用 red_send() 调用数据发送方，发送端通过 udt_send() 发送分组， 在通过不可靠信道后，接收端通过rdt_rcv()接收，通过deliver_data() 向上交付数据

#### `构造可靠数据传输协议`

> 版本一 : 经完全可信信道的可靠数据传输 (无差错，按序接收)

有限状态机(FSM),定义了主机的操作

rdt 发送端只通过 red_send(data)事件 接收较高层数据，产生包含该数据的分组(经由 packet = make_pkt(data) )，并将分组发送到信道中(udt_send(packet) ) ,red_send(data)事件由较高层应用的过程调用产生

rdt 接收端 通过 rdt_rcv(packet)事件 接收分组，从分组取出数据( extract(packet,data) ) ,在上传到较高层 (deliver_data(data) ) ， rdt_rcv(packet)事件由较低层协议的过程调用产生

接收方不需要提供任何反馈信息给发送方，因为没有差错

> 版本二： 经具有比特差错信道的可靠数据传输 (虽然会有差错但是还是按序接收且不丢失分组
)

在分组的传输，传播或缓存过程中出现比特差错 (经常出现于物理部件中)

自动重传请求(ARQ)： 基于重传机制的可靠数据传输协议

`ARQ协议功能` ：1. 差错检测(例如 检验和字段) 2. 接收方反馈(接收方反馈一个ACK或NCK，表示信息是否正确) 3. 重传(信息不正确，发送方重传该分组文)

停留协议： 发送方在确认接收方已经正确接收当前分组前不会发生新的数据

`接收方反馈过程中可能出错`，how： 发送方收到含糊不清的NCK或ACK分组时，重传当前数据分组(即 引入 冗余分组)

`接收方不知道重传的数据分组是旧的还是新的`，how ： 对数据分组进行编号，添加序号字段，(对于停留协议，只需要 0 或 1 即可)

`检验和，序号，ACK分组和重传`

> 版本三 经具有比特差错的丢包信道的可靠数据传输

因为数据分组可能会丢失，我们需要 倒计时定时器(发送方) : 1. 每次发送一个分组便启动一个定时器 2. 响应定时器中断 3.终止定时器

因为分组序号在 0 和 1 之间交替 ，称为比特交替协议 

> 总结 `比特交替协议`

传输内容是否存在差错 ： 检验和 

分组丢失后重传分组 ： 倒计时定时器(发送方)

发送方如何知道接收方接收的是正确的 ： ACK分组

接收方不知道重传的数据分组是旧的还是新的： 分组序号(在 0 和 1 之间交替)

停留协议 ：发送方在确认接收方已经正确接收当前分组前不会发生新的数据

### `流水线可靠数据传输协议`

停留协议的`信道利用率`很低，性能不高。所以我们需要不以停等的方式，运行发送方发送多个分组而无需等待确认

不同: 1. 增加序号范围，每个运输中的分组都得有唯一序号 2. 协议的发送方和接收方要缓存更多分组(发送方至少要缓存已发送但没有确认的分组 ， 接收方缓存已正确接收的分组 ) 

流水线差错恢复 方法 ： 1. 回退N步(GBN)  2. 选择重传(SR)

### `回退N步(GBN) ：滑动窗口协议`

what：允许发送方发送多个分组无需等待，但且限于流水线中未确认分组数不超过N

基序号(base): 最早为确认分组的序号  下一个序号(nextseqnum):最小的未使用序号

[0,base-1]: 已发送已确认 [base,nextseqnum-1]:已发送未确认 [nextseqnum,base+N-1]：立即要被发送   [base+N, ] ： 不能发送

流量控制是对发送方施加限制的原因之一

GBN发送方必须响应3种类型事件： 

1. ``上层的调用。`( 调用rdt_send()时，先看发送窗口满没满，没满则发送并更新变量 ，满了 要么缓存，要么使用同步机制，确保上层只有不满时才能调用rdt_send)   

2. `收到一个ACK`。在GBN协议中，采用累积确认，收到序号为n的ACK，说明之前的所有分组也都被接收。  

3. `超时事件`： 出现丢失或时延过长  发送方**重传所有已发送但未确认的分组**，定时器为最早已发送但未确认分组所使用的定时器。且收到ACK，如果仍有已发送但为确认分组，重启定时器，如果没有，停止定时器

**在GBN协议中，接收方丢弃所有失序分组** ,所有接收方只要维护一个 下一个按序接收的分组序号即可 ，接收缓存简单。

基于事件的编程：每个过程实现了在响应各种可能出现的时间时采取的动作 。比如 在发送方：1.上传实体调用rdt_send  2.定时器中断 3， 报文到达时，下层调用 rdt_rcv 

问题： 性能不高，在窗口长度(N)和带宽延迟较大的情况，单个分组出错就会重传大量分组。其实很多分组没有重传必要

### `选择重传(SR)`

SR 让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要重传。要求接收方逐个确认正确接收的分组。还是用窗口长度N，限制 发送的分组数

SR 接收方将失序的正确接收分组缓存，而不是丢弃。 (比如 先接收到 1 2 最后接收 0 ，那么 0 1 2 会一并交付)

`SR发送方事件与动作`: 

`1`. 从上层收到数据。 ( 检查 窗口(窗口大小为 [send_base,send_base+N] )是否还有序号，缓存数据或不允许发送)  

`2`. 超时 (每个分组有自己的逻辑定时器,超时后只发送一个分组 )

 `3.` 收到ACK (如果 接收序号在窗口内 标记已确认 ，如果序号等于send_base ，窗口向前滑动，send_base改为 最小未确认分组号 ,如果移动窗口后存在已缓存但为发送数据 发送他们 ) 

`SR接收方事件与动作`： 

`1.` 序号在[rec_base,rec_base+N-1] 内分组被正确接收 。(发送该序号的ACK ，如果为接收过则缓存 ，如果 序号恰好等于 rec_base ，将该序号和之后连续的一段缓存全部交付给上层 ，rec_base 更新为最小为接收分组号 )

` 2.` 接收序号在 [rec_base-N,rec_base-1] 间( 说明发送方当前send_base被正确接收但是返回的ACK丢失 ，导致窗口不一致)，发送ACK确认，使得发送方能继续滑动窗口  

 `3.` 其他情况，例如 因为网络延迟，接收方和发送方窗口都不存在该序号  。  那么忽略该分组

`窗口长度必须小于或等于序号窗口大小的一半`： 因为比如 序号空间 4 ，窗口大小 3 ，那么 假设 0 1 2 都被正确结束以后 ，则 接收方窗口应为 （3 0 1） ,那么发送方发送 0  ,接收方不知道 0 是新数据还是之前 0 的重发

因为可能有其他情况例如 很久以前的数据但序号是当前序号信号，所以  例如确保一个序号x不被重新使用，直到发送方`确信` 任何 序号为 x 的分组都不存在在网络中为止。 通过假定一个分组在网络中的存活时间不会超过某个固定最大时间量解决( 最大寿命被假定为3分钟)

<h2 id='3-5'> 面向连接的运输：TCP </h2>

差错检测，重传，累积确认，定时器，用于序号和确认号的首部字段

### `TCP连接`

TCP是`面向连接`的，在发送数据之前必须进行三次握手,发送预备报文段，以建立确保数据传输的参数，连接双方初始化许多TCP状态变量

TCP连接是`全双工`：双方都能传输数据 ，也是`点对点`(单个发送方和单个接收方)的

三次握手：客户发送一个特殊TCP报文段，主机用另一个特殊报文段响应，客户再用第三个特殊报文段响应(第三个可以承载应用层数据，前两个不承载**有效载荷**)

客户进程通过**套接字**将数据传递个TCP，TCP会先将数据放在 TCP连接的发送缓存中(发送缓存在三次握手时建立)，然后TCP会取出缓存的一部分数据发送到网络层。这一部分数据的最大长度受限于 **最大报文段长度(MSS)**，MSS根据由**最大链路层帧长度(MTU)**设置

以太网和PPP链路的MTU为 1500字节 ，而且 TCP/IP 首部信息为40字节，所以MSS为1460字节(MSS指的是报文段应用层数据最大长度，不包括TCP报文段首部)

TCP为每块客户数据加上TCP首部，变成TCP报文段

TCP从另一端接收报文段，然后该报文段数据被放入TCP缓存中，应用进程从TCP缓存中读取数据流

### `TCP报文结构`

TCP发送大数据时，通常会分为长度为MSS的若干块

TCP首部大小一般为20字节
```
组成:1. 源端口号(16比特) 2. 目的端口号(16) 3. 序号(32) 4. 确认号(32) 5. 首部长度(4) 6. 标志字段(6) 7. 接收窗口(16) 8.因特网检验和(16) 9. 紧急数据指针(16)  10.选项  

序号和确认号： 用来实现可靠数据传输服务

接收窗口：接收方愿意接收的字节数量(流量控制)

首部长度: 因为选项字段，所以TCP首部长度可变(通常，选项为空，TCP长度为20字节)

选项:  用于发送方和接收方协商MSS时

标志字段： ACK比特 确认有效  PST ，SYN，FIN 创建连接和拆除  PSH ，被置位时指示接收方立刻将数据交给上层 
URG，是否存在紧急数据

紧急数据指针： 指出紧急数据的最后一个字节
```

> 1. 序列号和确认号

报文段的`序号`是该报文段首字节的**字节流编号**(例如 5000字节文件 ，MSS为1000 ，那么公有5个字节流标号 0 1 2 3 4)

`确认号`: 因为TCP为全双工，A可能收到B的数据，A主机填充进给B的报文段的确认号为主机A期望从主机B收到的**下一字节**的编号 ，例如A收到B发送字节 0 - 99 ，200 - 299 ，那么确认号填的是 100

确认号代表确认号之前的字节数据都被正确接收，TCP只确认该流中至第一个丢失字节为止的字节，所以说`TCP提供累积确认`

TCP连接的双方均可以随机选择初始序号，这样可以使之前终止连接却仍在网络中的报文段 被误认为 新连接的有效报文段

>2.  telnet:序号和确认号学习的一个案例(交互式应用)

现在更多使用SSH，因为telnet是发送数据是不加密的

`回显`：客户连接到主机以后。客户键入的每个字符会直接发送给服务器，服务器再会送字符的副本给客户，然后将字符显示在客户屏幕上。**这样能确保服务器已经接收并得到处理**
```
在握手时，客户和服务器已经交换各自起始序号，例如 主机 42 ，主机 79
过程： 1. 客户发给服务器 序号42 确认号79 字符 c
       2. 服务器发给客户 序号79 确认号 43 字符c (主要是发送数据，确认是捎带的)
       3. 客户发给服务器  序号43 确认号80 
```

### `往返时间的估计和超时`

如何确认定时时间

> 1. 估计往返时间

报文段的样本RTT(SampleRTT)：某报文段被发出(交给IP)到该报文段的确认被收到之间的时间量。

任意时刻，仅为一个已发送但目前尚未确认的报文段估计SampleRTT，从而产生一个接近每个RTT的新SampleRTT值；仅为传输一次的报文段测量SampleRTT值(因为已被重传的报文段可能已被缓存)

TCP维持一个SampleRTT均值即(`EstimatedRTT`), 获得新的SampleRTT，会根据公式更新

`EstimatedRTT = ( 1 - A ) * EstimatedRTT + A * SampleRTT  (A一般为0.125)`

EstimatedRTT是一个SampleRTT的加权平均值，对新样本的权值大于旧样本

定义 `DevRTT `，估算SampleRTT偏离EstimatedRTT程度（网络波动程度）

`DevRTT = ( 1 - B ) * DevRTT + B * abs( SampleRTT - EstimatedRTT )  (B一般为0.25)`

> 2. 设置和管理重传超时间隔

应该比EstimatedRTT大，但是不能大太多(降低时延)。根据DevRTT设置余量

` TimeoutInterval = EstimatedRTT + 4 *  DevRTT `

一开始没有SampleRTT时 初始值为1s，如果超时，值加倍避免再次超时，当收到报文段确认时，计算TimeoutInterval

TCP使用了流水线。 可能也使用隐式NAK机制，(快速重传),收到对一个特定版本号的3个冗余ACK，就会对后面报文段进行重传

### `可靠数据传输`

TCP的可靠数据传输服务确保 一个进程从其接收缓存中读出的数据流是无损坏，无间隙，非冗余和按序的数据流

**TCP使用单一的重传定时器**(开销小) 

**TCP采用累积确认**(可以避免一些不必要的重传)

```
发送方响应事件：
1. 从上层程序接收数据。 接收数据，封装在报文段，发送给IP。 他的序号就是报文段第一个数据字节的字节流编号  。如果定时器还没启动，则启动定时器，间隔为TimeoutInterval

2. 超时。 超时后重传最小序号但仍未应答的报文段，再启动定时器

3. 接收包含有效ACK字段值的报文段。 通过确认号(期待的字节序号)与sendbase（最早未被确认的字节的序号）比较，若确认号大，sendbase 更新为确认号(因为是累积确认) ，有未确认报文段的话会重启 定时器
```

> 超时间隔加倍

定时器发生超时事件时，他的定时器时间是先前值的两倍。不过如果定时器在其他两个事件(收到反馈或者上层应用传送数据)启动时，定时器还是由 EstimatedRTT 和 DevRTT 推算

因为定时器过期可能是由于网络拥塞导致，源持续重传分组会加重拥塞。(形式受限的拥塞控制)

> 快速重传

`冗余ACK`: 再次确认某个报文段的ACK

为什么会产生冗余ACK: 因为当接收方接收的序号大于所期望的按序序号时，会发送一个已经接收到的最后一个按序字节数据进行重复确认，所以说TCP的确认时`累积确认`

一个应该按序到达的报文段如果丢失，接收方会发出大量冗余ACK

所以TCP发送方接收到三个冗余ACK后就会执行快速重传，而不是等待计时器过期

> 回退N步还是选择重传

TCP的确认时累积式的，正确接收但是失序的报文段是不会被接收方逐个确认的，如果期望报文段未接收，却接收了三个失序报文段，就会激发发送方的快速重传，快速发送丢失报文段

`选择确认`，允许接收方有选择的确认失序报文段，而不是累积的确认最后一个正确接收的有序报文段,而发送方会跳过确认那些已被接收方选择性确认过的报文段

### `流量控制`





