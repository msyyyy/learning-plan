**个人理解，并不保证正确，有大佬发现偏差欢迎指教**

## 操作系统

1. **进程的状态**

   - 可执行状态   R

   ​	这些进程的PCB被放入可执行队列中

   - 可中断的睡眠状态  S

     等待某某事件发生，PCB在对应事件的等待队列中

   - 不可中断的睡眠状态   D

     内核的某些处理流程是原子操作，是不能中断的

   - 暂停状态  T

     进程收到SIGSTOP，SIGSTP ,SIGTIN, SIGTOU信号后终止

   - 僵尸状态  Z

     进程占用资源被回收，除了PCB，PCB中保存进程的退出码和一些信息

2. **进程和线程**

   进程是系统进行资源分配的基本单位，有独立的内存地址空间

   线程是程序执行时的最小单位，是进程的执行流，与其他同一进程下的线程共享数据区，堆区，但是有自己独立的栈区

   从性能上比较，线程具有如下优点：

   1. 在一个已有进程中创建一个新线程比创建一个全新进程所需的时间要少许多
   2. 终止一个线程比终止一个进程花费的时间少
   3. 同一进程内线程间切换比进程间切换花费的时间少
   4. 线程提高了不同的执行程序间通信的效率（在大多数操作系统中，独立进程间的通信需要内核的介入，以提供保护和通信所需要的机制。但是，由于在同一个进程中的线程共享内存和文件，它们无须调用内核就可以互相通信）

3. **进程的地址空间布局**

   从上到下是栈区，堆区，未初始化数据区，初始化数据区，代码区

4. **进程间通信的方法**

   - 管道

     半双工通信，如果要同时读写，要创建两个管道，分为有名管道和无名管道，无名管道只用于亲缘进程间

   - 信号量

     它是一个计数器，用于为多个进程提供对共享数据对象的访问。

   - 消息队列

   - 共享内存

     映射一段能被其他进程访问的内存，优点：无需复制  缺点：需要解决进程间的同步问题

   - 套接字

     可用于不同机器间的进程通信

5. **进程的创建**

   - 创建一个PCB
   - 分配内存
   - 初始化PCB
   - 将PCB放入相应的队列中( 进程有执行，阻塞，就绪三个状态)

6. **进程的终止**

   进程不再执行，但是PCB会保留一个记录(状态码和一些计时统计数据供其他进程收集，一旦收集完成，PCB完全清空)

7. **进程调度算法**

   要根据不同的系统选择合适的算法

   如**批处理系统**没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间

   - 先来先服务，按请求顺序进行服务，可能会导致短作业等待时间过长
   - 短作业优先，可能会导致长作业一直得不到调度
   - 最短剩余时间优先

   如**交互式系统**有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应

   - 时间片轮转
   - 优先级调度
   - 多级反馈队列(时间片轮转+优先级调度)

8. **死锁**

   各进程互相等待对方手里的资源，造成无法向下推进的情况

   **产生原因**： ①：系统资源不足  ②：资源分配不当  ③：进程推进顺序不合理

   **产生条件**:        ①：互斥 ，某资源只能同时被一个进程占用

   ​			②：请求和保持，进程已经保存了至少一个资源，又请求新的资源

   ​			③： 资源不可剥夺，被进程占用的资源只能等待进程自己释放

   ​			④ ：循环等待，有一个资源等待循环链，比如a等待b具有的资源，b等待a具有的资源

   **预防**:    ①：打破不可剥夺条件，当进程已占用资源又申请资源而无法满足时，则退出原占有的资源

   ​	     ②：打破请求和保持条件，采用资源预分配策略，即程序运行前申请全部所需资源，如果不满足则等待

   ​	   ③：打破循环等待条件,对所有资源编号，所有进程只有按序号递增申请资源，如果申请序号小的资源，需要把序号大的资源都释放

9. **自旋锁和互斥锁**

   互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。

   自旋锁：与互斥量类似，它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等(自旋)阻塞状态，会占用cpu。用在以下情况：锁持有的时间短，而且线程并不希望在重新调度上花太多的成本。"原地打转"。

   自旋锁与互斥锁的区别：线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。

10. **虚拟内存**

   虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

   为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

11. **页面置换算法**

    - 最佳 OPT

      所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

      是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

    - 最近最久未使用 LRU

      LRU 将最近最久未使用的页面换出。

      为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

    - 时钟

      第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。有个标志位，如果为1代表最近有访问过，不需要置换这个

12. **分段和分页**

    段页式：

    程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

    - 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
    - 地址空间的维度：分页是一维地址空间，分段是二维的。
    - 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
    - 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

13. **编译链接过程**

    ![img](https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg)

    - 预处理阶段：处理以 # 开头的预处理命令；
    - 编译阶段：翻译成汇编文件；
    - 汇编阶段：将汇编文件翻译成可重定位目标文件；
    - 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。

    

14. **静态链接**

    静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

    - 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
    - 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

    ![img](https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg)

    

15. **动态链接**

    静态库有以下两个问题：

    - 当静态库更新时那么整个程序都要重新进行链接；
    - 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

    共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

    - 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
    - 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

    ![img](https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg)

16. 











## 网络

1. **TCP三次握手**

   假设A为客服端，B为服务器端

   - B处于listen状态
   - A向B发送一个请求报文，SYN置为1，ACK为0，序号为x，A进入SYN_SENT状态
   - B向A发送确认报文，SYN置为1，ACK为1，序号为y，确认号为x+1，B进入SYN_RECVD状态
   - A向B发送确认报文，ACK置为1，序号为x+1，确认号y+1,A结束SYN_SENT状态，B结束SYN_RECVD状态
   - 只有第三次握手才能传输数据

2. **为啥需要三次握手**

   防止已失效的请求报文再次到达服务器端，造成服务器端的资源浪费

3. **TCP四次挥手**

   假设A为客户端，B为服务器端

   - A向B发送一个请求断开报文，FIN置为1，序号为 x，A进入FIN_WAIT_1状态
   - B向A发送确认报文，ACK为1，序号为y，确认号为x+1，B进入CLOSE_WAIT状态
   - B向A发送请求断开报文，FIN置为1，序号为z，确认号为x+1,B进入LAST_ACK状态，A进入FIN_WAIT_2状态
   - A向B发送确认报文，序号为x+1，确认号为z+1，A进入TIME_WAIT状态，持续2MSL，B接收LAST_ACK状态

4. **为什么要四次挥手**

   因为TCP是全双工的，客户端和服务器端都要发送请求断开报文和确认报文，当服务器收到请求断开的报文时，服务器可能还有未传输完的数据，等数据传输完后才会发送请求断开报文


5. **TIME_WAIT的作用**

   - 确保客户端发送的确认报文能到达客户端
   - 确保本次TCP连接中产生的有效报文段都从网络中消失

6. **为什么要2MSL**

   - ACK从A到B最多1MSL，超过这个时间，B会重发FIN
   - B重发的FIN报文最多1MSL到达A

   所以如果B重发FIN报文，在2MSL时间内一定能被A收到

7. **UDP和TCP的区别**

   - UDP是无连接的，支持 广播和多播，TCP是有连接的，全双工通信的的
   - UDP是尽最大努力交付，但不保证什么，TCP保证数据按序，完整到达
   - UDP首部8字节，TCP首部20字节(不考虑偏移量)
   - UDP面向报文，TCP面向字节流，(数据块数量可以不相等，但是字节数一样)
   - UDP有拥塞控制，TCP没有拥塞控制

8. **TCP如何保证可靠性**

   - 建立连接(标志位)   ：通信前确认通信实体存在
   - 序号和确认号 ：保证数据按序，完整到达
   - 检验和： 保证数据正确
   - 超时重传： 保证丢失的数据能重发
   - 滑动窗口：减轻接收方接收数据的压力大小，流量控制
   - 拥塞控制：减轻网络传输数据的压力大小

9. **TCP滑动窗口**

   TCP滑动窗口主要是为了进行流量控制，让接收端口来得及接收。

   因为TCP是全双工的，发送端和接收端都要维护一个发送窗口和接收窗口

   发送窗口是用来现在发送方可以发送的数据大小，数值依赖于接收端发来的TCP报文中的窗口字段大小

   接收窗口是标记可接收的数据大小

   发送数据分为  1.已发送且被确认 2. 已发送但未被确认 3. 未发送但可发送 4. 不可发送

   发送窗口指的是 2 ，3 部分

   接收数据分为 1.已接收 2. 未接收但准备接收 3. 未接收但不准备接收

   接收窗口为 2 部分

   发送窗口只有收到某个未确认数据的ACK响应时，才移动窗口，因为TCP时采用累积确认的方法，接收到ACK时，代表该确认号之前的数据都被正确接收

   接收窗口只有当接收到数据且最左侧连续时才移动

10. **当接收窗口为0时怎么办**

  客户端会启动零窗口探测定时器，定期向接收端发送探测报文

11. **滑动窗口的缺点**

    如果发送方网络状态不好或者接收方接收的比较慢，这样发现的都是很小的数据包，造成网络资源的浪费，可以使用nagle算法。让一个TCP连接中同时只能有一个未被确认的小分组

12. **TCP拥塞控制**

    TCP拥塞控制分为3个部分 ①. 慢启动 ②. 拥塞避免 ③. 快速恢复

    慢启动是将拥塞窗口cwnd设置为 1MSS (最大报文段长度)，然后每收到一个确认报文，cwnd增长1MSS，所以慢启动是2倍增长的

    **慢启动**有3个停止的方法 ①. 由超时指示的丢包，这时cwnd重置为1，重新开始慢启动  ② cwnd超过慢启动阈值，进入拥塞避免状态 ③ 由三个冗余ACK指示的丢包，先快速重传，然后进入快速恢复状态

    **拥塞避免**，是线性增长的，每个连接返回时间(RTT) 增长1MSS ，防止增长速率过快，导致丢包

    **快速恢复**，阈值变为原cwnd的一半，cwnd也变为原cwnd的一半，进入拥塞避免状态。让拥塞窗口不需要从1MSS开始增长，加快恢复速度

13. **ARP的工作原理**

    主机向自己所在的网络广播一个ARP请求，请求包含目标机器的网络地址，此网络的其他机器都会收到这个请求，不过只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址

    通常维护一个高速ARP缓存，其中包含经常访问或是最近访问的目标机器IP地址到物理地址的映射，避免重复请求

14. **I/O复用 select和epoll的区别**

    IO复用是为了提高效率，让一个进程能同时监听多个文件描述符

    **select** ①每次都要将整个fd_set数组从应用进程缓冲区复制到内核缓冲区，这是很慢的(  CPU要在用户态和核心态之前切换，堆栈需要恢复上下文)

    ② select返回的是整个fd_set数组，需要通过轮询每一位才知道哪些描述符变化

    不过select也有优点，在多个操作系统中均有实现，可移植性强

    **epoll**是通过维护一个内核事件表，每个的文件描述符只需要向内核注册一次，已注册的描述符维护在红黑树上，通过回调函数，内核将发生变化的描述符 加到链表上，进程通过epoll_wait得到所有发生变化的描述符

    所有说epoll只需要将描述符从进程缓冲区向内核缓冲区复制一次，而且不需要通过轮询获得变化的描述符

    select只支持水平触发，而epoll可以设置为边缘触发

15. **水平触发和边缘触发**

    水平触发就是一个事件，你如果不处理他，他会重复触发，所以当事件发生时，你可以不立即处理他或不处理完，下次还是会触发该事件

    边缘触发，一个事件只会触发一次，所有当事件发生时，必须立刻处理完

    边缘触发减少同一事件的重复触发次数，因此效率比水平触发高

16. **同步IO和异步IO**

    IO有两个阶段

    ① 数据准备阶段   ( 非阻塞可以在此阶段做别的事)

    ② 从内核向进程复制数据 ( 异步可以在此阶段做别的事)

    同步IO是程序进行IO操作，在内核向进程复制数据这一阶段，程序被阻塞

    异步IO是内核进行IO操作，当IO完成时，通知程序数据的存储地址，所有在内核向进程复制数据这一阶段，程序可以完成别的操作

17. **键入一个url到返回网址会发生什么**

    - 先解析url是否正确

    - 在浏览器的HSTS表中查询该url是否存在，存在的话默认访问方式是https

    - 在主机host 查询是否有对应IP

    - 访问本地dns服务器

    - 如果本地dns服务器和主机在同一个子网，那么ARP请求本地dns服务器，如果不在同一个子网，那么先ARP请求默认网关，在ARP请求本地dns服务器

    - 通过dns找到目标主机ip

    - 如果是https，会先进行ssl

    - http是依赖于tcp的，所以进行tcp三次握手

    - http访问，得到请求资源

    - 在本地解析并渲染

      

## C++  

1. **右值引用**

   左值： 地址值，可以被赋值

   右值：数据值，不可被赋值，不能被访问地址，即将消亡的数据

   如 int a,b   为左值   a+b为右值

   右值引用可以延长右值的生存周期，窃取其资源而不需要进行拷贝

   例如有个函数返回一个类的对象，那么他先对返回的那个值进行了构造函数，然后接收返回值的那个值调用拷贝构造函数

   如果使用右值引用，就能使用移动构造函数，窃取函数中的返回值对象资源，不需要再调用拷贝构造函数

   之前不能被访问的右值地址现在为接收值的地址了，接收值是左值能被访问

   move可以将左值变为一个右值，move指针，接收值指向原内存地址，原指针失效，move基础值无意义

2. **智能指针**

   c++11后只有shared_ptr、unique_ptr、weak_ptr

   智能指针主要是为了解决内存泄漏的问题，智能指针把普通指针封装成类，然后使用**引用计数**，在引用数为0时，自动释放占用的内存。普通指针可能会有忘记释放或多次释放的问题，智能指针不会

   shared_ptr，多个指针能指向相同的对象，不过可能出现循环引用的问题，循环引用可以由week_ptr解决

   week_ptr，弱指针，指针指向对象，但是对应引用计数不增加，观测资源。**循环引用**是a类有指针指向b，b类有指针指向a（现在新建2个指针  a* p1, b* p2   ,先将p1=nullptr，但是指向a的引用计数为2，现在为1，不会将a析构，p2也一样，所以最后a和b都不会被析构），**解决**：类里的指针用week_ptr

   unique_ptr, 同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）

3. **多态**

   多态分为动态多态和静态多态

   静态多态是**函数重载**，在编译时确定调用哪个函数。函数重载是函数相同，形参列表不同( 形参类型 和数量 ) 和返回值类型无关

   动态多态是**虚函数**，在运行时确定调用哪个类的虚函数。一个基类指针指向派生类对象，当对这个指针调用虚函数时，调用的虚函数为派生类的虚函数，这就是动态绑定

   **如何实现**: 每个有虚函数的类都有一个虚函数表指针，指向虚函数表(虚函数表在程序只读数据段)。虚函数表存储着类的所有虚函数位置，派生类继承基类时会先继承基类的虚表然后再对其进行修改

   每个类对象再创建时，编译器会自动加上那个虚表指针，所以使用该对象时，调用的就是该类虚表中的虚函数

4. **虚函数（virtual）可以是内联函数（inline）吗？**

   虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联

5. **虚函数和纯虚函数**

   虚函数是有实现的，而纯虚函数只是声明，要在子类中实现

   带纯虚函数的类叫抽象类，他不能直接生成对象

6. **虚继承**

   虚继承用于解决多继承条件下的**菱形继承问题**（浪费存储空间、存在二义性）。

   底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

   实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

7. **构造函数中能调用虚函数，实现多态吗？**

   父类先于子类被构造，当父类中的构造函数被调用时，子类还没有形成，此时子类对于编译器来说是不存在的，所以调用的仍是父类本身的虚函数。

   构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）

8. **析构函数要不要设置成虚函数**

   需要，因为如果析构函数不为虚函数，那么当删除基类指针指向的派生类对象时，不会触发动态绑定，只会调用基类的析构函数而不会调用派生类的析构函数，造成内存泄漏

9. **数组名和指针的区别**

   数组名相当于含有数组大小的指针常量

   数组名不能++，--

   sizeof(指针) ，显示指针大小，sizeof(数组名) ,显示数组大小

10. **重载，隐藏，覆盖**

  重载：同一作用域下几个函数的函数名称相同，形参列表不同

  隐藏:  派生类的函数屏蔽了与其同名的基类函数，只要函数名一样就会	   屏蔽，不考虑形参列表

  覆盖:  依靠虚函数实现，派生类中存在重新定义的虚函数，其函数名，	   返回值类型，参数列表都必须和被覆盖的函数一直，当基类指针	   指向的是派生类对象时，调用该函数会调用派生类中的函数

  

11. **野指针和空悬指针**

   野指针是为初始化的指针，空悬指针是指向对象已经被释放，但为让其指向空的指针

12. **const**

   1. 修饰变量，说明该变量不可以被改变；
   2. 修饰指针，分为指向常量的指针和指针常量；
   3. 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
   4. 修饰成员函数，说明该成员函数内不能修改成员变量。const成员函数，仅能使用const成员函数
   5. **在C++中，只有被声明为const的成员函数才能被一个const类对象调用。**

13. **static作用是什么**

   - static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；
   - 修饰函数时作用和修饰全局变量相同，都是为了限定访问域。
   - C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。
   - 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。
   - static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。
   - 未初始化时，static变量默认值为0。

14. **molloc和new的区别？**

   - malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。
   - malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。
   - malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。
   - new内存分配失败，会抛出异常，molloc分配失败返回null
   - new不需要指定内存大小，molloc需要显示指定大小

15. **指针和引用区别？**    

   - 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。

   - 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
   - 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
   - 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

16. **宏定义和const区别？**

   - 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。
   - 宏不检查类型；const会检查数据类型。
   - 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。

## 数据库

1. **三大范式**

   - 第一范式： 属性不可分割
   - 第二范式： 非主属性完全函数依赖于候选码
   - 第三范式： 非主属性不传递函数依赖于候选码
   - BCNF范式： 主属性完全函数依赖于候选码且不传递函数依赖于候选码

   在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X **完全函数依赖**

   在『Y 不包含于 X，且 X 不函数依赖于 Y』这个前提, 假如 Z 函数依赖于 Y，且 Y 函数依赖于 X，那么我们就称 Z **传递函数依赖**于 X

   设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为**候选码**，简称为**码**。在实际中我们通常可以理解为：**假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。**一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为**主码**）

   满足一不满足二  ： 主码 (学号 ，课程)      分数，姓名

   只有一个表的话，学号和姓名其实是完全函数依赖的，而主码和姓名是部分函数依赖，应该要分两张表  

   【学号 课程 分数】    ，

   【学号 姓名】

   满足二不满足三：主码（学号） 系名 系主任

   系名依赖学号 ，系主任依赖系名

   应该分两张表  【学号  系名】 【系名，系主任】 

   

   

2. **事务**

   满足ACID的一组操作

   - A  原子性

     事务被视为不可分割的最小单元，事务的所有操作要么都成功要么都失败回滚

     回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

   - C  一致性

     数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

   - I  隔离性

     一个事务所做的修改在最终提交以前，对其它事务是不可见的。

   - D 持久性

     一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。使用重做日志来保证持久性。

3. **并发一致性问题**

   - 丢失数据
   - 脏读
   - 不可重复读
   - 幻读

4. **多版本并发控制**

    [mysql](<https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md>)

5. **文件系统及数据库系统普遍采用 B+ Tree 作为索引结构**

   （一）更少的查找次数

   平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。

   红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

   （二）利用磁盘预读特性

   为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。

   操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

6. **聚簇索引和非聚簇索引**

   聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。



---

**常用代码**

```c++
// 懒汉式 单例模式
class a
{
    public:
    static a& f()
    {
        static a b;
        return b;
    }
}
//饿汉式
class a
{
    a(){}
    public:
    	static a& get()
        {
            return b;
        }
    private:
        static a b;
    
}
```

```c++
//LRU
class LRUCache {
private:
    int cap;
    int count;
    unordered_map<int, list<pair<int, int>>::iterator> m;
    list<pair<int, int>> queue;

public:
    LRUCache(int capacity) {
        cap = capacity;
        count = 0;
    }

    int get(int key) {
        int res = -1;
        auto p = m.find(key);
        if (p != m.end()) {
            res = p->second->second;
            queue.erase(p->second);
            queue.push_front(make_pair(key, res));
            p->second = queue.begin();
        }
        return res;
    }

    void put(int key, int value) {
        auto p = m.find(key);
        if (p != m.end()) {
            queue.erase(p->second);
        }
        else if (count == cap) {
            int delkey = queue.back().first;
            queue.pop_back();
            m.erase(delkey);
        }
        else {
            ++count;
        }
        queue.push_front(make_pair(key, value));
        m[key] = queue.begin();
    }
};

```

