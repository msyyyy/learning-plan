**个人理解，并不保证正确，有大佬发现偏差欢迎指教**

## 操作系统

1. **进程的状态**

   - 可执行状态   R

   ​	这些进程的PCB被放入可执行队列中

   - 可中断的睡眠状态  S

     等待某某事件发生，PCB在对应事件的等待队列中

   - 不可中断的睡眠状态   D

     内核的某些处理流程是原子操作，是不能中断的

   - 暂停状态  T

     进程收到SIGSTOP，SIGSTP ,SIGTIN, SIGTOU信号后终止

   - 僵尸状态  Z

     进程占用资源被回收，除了PCB，PCB中保存进程的退出码和一些信息

2. **进程和线程**

   进程是系统进行资源分配的基本单位，有独立的内存地址空间

   线程是程序执行时的最小单位，是进程的执行流，与其他同一进程下的线程共享数据区，堆区，但是有自己独立的栈区

   从性能上比较，线程具有如下优点：

   1. 在一个已有进程中创建一个新线程比创建一个全新进程所需的时间要少许多
   2. 终止一个线程比终止一个进程花费的时间少
   3. 同一进程内线程间切换比进程间切换花费的时间少
   4. 线程提高了不同的执行程序间通信的效率（在大多数操作系统中，独立进程间的通信需要内核的介入，以提供保护和通信所需要的机制。但是，由于在同一个进程中的线程共享内存和文件，它们无须调用内核就可以互相通信）

3. **进程的地址空间布局**

   从上到下是栈区，堆区，未初始化数据区，初始化数据区，代码区

4. **进程间通信的方法**

   - 管道

     半双工通信，如果要同时读写，要创建两个管道，分为有名管道和无名管道，无名管道只用于亲缘进程间

   - 信号量

     它是一个计数器，用于为多个进程提供对共享数据对象的访问。

   - 消息队列

   - 共享内存

     映射一段能被其他进程访问的内存，优点：无需复制  缺点：需要解决进程间的同步问题

   - 套接字

     可用于不同机器间的进程通信

5. **进程的创建**

   - 创建一个PCB
   - 分配内存
   - 初始化PCB
   - 将PCB放入相应的队列中( 进程有执行，阻塞，就绪三个状态)

6. **进程的终止**

   进程不再执行，但是PCB会保留一个记录(状态码和一些计时统计数据供其他进程收集，一旦收集完成，PCB完全清空)

7. **进程调度算法**

   要根据不同的系统选择合适的算法

   如**批处理系统**没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间

   - 先来先服务，按请求顺序进行服务，可能会导致短作业等待时间过长
   - 短作业优先，可能会导致长作业一直得不到调度
   - 最短剩余时间优先

   如**交互式系统**有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应

   - 时间片轮转
   - 优先级调度
   - 多级反馈队列(时间片轮转+优先级调度)

8. **死锁**

   各进程互相等待对方手里的资源，造成无法向下推进的情况

   **产生原因**： ①：系统资源不足  ②：资源分配不当  ③：进程推进顺序不合理

   **产生条件**:        ①：互斥 ，某资源只能同时被一个进程占用

   ​			②：请求和保存，进程已经保存了至少一个资源，又请求新的资源

   ​			③： 资源不可剥夺，被进程占用的资源只能等待进程自己释放

   ​			④ ：循环等待，有一个资源等待循环链，比如a等待b具有的资源，b等待a具有的				资源

   **预防**:    ①：打破不可剥夺条件，当进程已占用资源又申请资源而无法满足时，则退出原占有的资源

   ​	     ②：打破请求和保持条件，采用资源预分配策略，即程序运行前申请全部所需资源，如果不满足则等待

   ​	   ③：打破循环等待条件,对所有资源编号，所有进程只有按序号递增申请资源，如果申请序号小的资源，需要把序号大的资源都释放

9. 

 


## 网络

1. **TCP三次握手**

   假设A为客服端，B为服务器端

   - B处于listen状态
   - A向B发送一个请求报文，SYN置为1，ACK为0，序号为x，A进入SYN_SENT状态
   - B向A发送确认报文，SYN置为1，ACK为1，序号为y，确认号为x+1，B进入SYN_RECVD状态
   - A向B发送确认报文，ACK置为1，序号为x+1，确认号y+1,A结束SYN_SENT状态，B结束SYN_RECVD状态
   - 只有第三次握手才能传输数据

2. **为啥需要三次握手**

   防止已失效的请求报文再次到达服务器端，造成服务器端的资源浪费

3. **TCP四次挥手**

   假设A为客户端，B为服务器端

   - A向B发送一个请求断开报文，FIN置为1，序号为 x，A进入FIN_WAIT_1状态
   - B向A发送确认报文，ACK为1，序号为y，确认号为x+1，B进入CLOSE_WAIT状态
   - B向A发送请求断开报文，FIN置为1，序号为z，确认号为x+1,B进入LAST_ACK状态，A进入FIN_WAIT_2状态
   - A向B发送确认报文，序号为x+1，确认号为z+1，A进入TIME_WAIT状态，持续2MSL，B接收LAST_ACK状态

4. **为什么要四次挥手**

   因为TCP是全双工的，客户端和服务器端都要发送请求断开报文和确认报文，当服务器收到请求断开的报文时，服务器可能还有未传输完的数据，等数据传输完后才会发送请求断开报文


5. **TIME_WAIT的作用**

   - 确保客户端发送的确认报文能到达客户端
   - 确保本次TCP连接中产生的有效报文段都从网络中消失

6. **为什么要2MSL**

   - ACK从A到B最多1MSL，超过这个时间，B会重发FIN
   - B重发的FIN报文最多1MSL到达A

   所以如果B重发FIN报文，在2MSL时间内一定能被A收到

7. **UDP和TCP的区别**

   - UDP是无连接的，支持 广播和多播，TCP是全双工通信的的
   - UDP是尽最大努力交付，但不保证什么，TCP保证数据按序，完整到达
   - UDP首部8字节，TCP首部20字节(不考虑偏移量)
   - UDP面向报文，TCP面向字节流，(数据块数量可以不相等，但是字节数一样)
   - UDP有拥塞控制，TCP没有拥塞控制

8. **TCP如何保证可靠性**

   - 建立连接(标志位)   ：通信前确认通信实体存在
   - 序号和确认号 ：保证数据按序，完整到达
   - 检验和： 保证数据正确
   - 超时重传： 保证丢失的数据能重发
   - 滑动窗口：减轻接收方接收数据的压力大小，流量控制
   - 拥塞控制：减轻网络传输数据的压力大小

9. **TCP滑动窗口**

   TCP滑动窗口主要是为了进行流量控制，让接收端口来得及接收。

   因为TCP是全双工的，发送端和接收端都要维护一个发送窗口和接收窗口

   发送窗口是用来现在发送方可以发送的数据大小，数值依赖于接收端发来的TCP报文中的窗口字段大小

   接收窗口是标记可接收的数据大小

   发送数据分为  1.已发送且被确认 2. 已发送但未被确认 3. 未发送但可发送 4. 不可发送

   发送窗口指的是 2 ，3 部分

   接收数据分为 1.已接收 2. 未接收但准备接收 3. 未接收但不准备接收

   接收窗口为 2 部分

   发送窗口只有收到某个未确认数据的ACK响应时，才移动窗口，因为TCP时采用累积确认的方法，接收到ACK时，代表该确认号之前的数据都被正确接收

   接收窗口只有当接收到数据且最左侧连续时才移动

10. **当接收窗口为0时怎么办**

  客户端会启动零窗口探测定时器，定期向接收端发送探测报文

11. **TCP拥塞控制**

    TCP拥塞控制分为3个部分 ①. 慢启动 ②. 拥塞避免 ③. 快速恢复

    慢启动是将拥塞窗口cwnd设置为 1MSS (最大报文段长度)，然后每收到一个确认报文，cwnd增长1MSS，所以慢启动是2倍增长的

    **慢启动**有3个停止的方法 ①. 由超时指示的丢包，这时cwnd重置为1，重新开始慢启动  ② cwnd超过慢启动阈值，进入拥塞避免状态 ③ 由三个冗余ACK指示的丢包，先快速重传，然后进入快速恢复状态

    **拥塞避免**，是线性增长的，每个连接返回时间(RTT) 增长1MSS ，防止增长速率过快，导致丢包

    **快速恢复**，阈值变为原cwnd的一半，cwnd也变为原cwnd的一半，进入拥塞避免状态。让拥塞窗口不需要从1MSS开始增长，加快恢复速度

12. **ARP的工作原理**

    主机向自己所在的网络广播一个ARP请求，请求包含目标机器的网络地址，此网络的其他机器都会收到这个请求，不过只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址

    通常维护一个高速ARP缓存，其中包含经常访问或是最近访问的目标机器IP地址到物理地址的映射，避免重复请求

13. **I/O复用 select和epoll的区别**

    IO复用是为了提高效率，让一个进程能同时监听多个文件描述符

    **select** ①每次都要将整个fd_set数组从应用进程缓冲区复制到内核缓冲区，这是很慢的(  CPU要在用户态和核心态之前切换，堆栈需要恢复上下文)

    ② select返回的是整个fd_set数组，需要通过轮询每一位才知道哪些描述符变化

    不过select也有优点，在多个操作系统中均有实现，可移植性强

    **epoll**是通过维护一个内核事件表，新的文件描述符只需要向内核注册一次，已注册的描述符维护在红黑树上，通过回调函数，内核将发生变化的描述符 加到链表上，进程通过epoll_wait得到所有发生变化的描述符

    所有说epoll只需要将描述符从进程缓冲区向内核缓冲区复制一次，而且不需要通过轮询获得变化的描述符

    select只支持水平触发，而epoll可以设置为边缘触发

14. **水平触发和边缘触发**

    水平触发就是一个事件，你如果不处理他，他会重复触发，所以当事件发生时，你可以不立即处理他或不处理完，下次还是会触发该事件

    边缘触发，一个事件只会触发一次，所有当事件发生时，必须立刻处理完

    边缘触发减少同一事件的重复触发次数，因此效率比水平触发高

15. **同步IO和异步IO**

    IO有两个阶段

    ① 数据准备阶段   ( 非阻塞可以在此阶段做别的事)

    ② 从内核向进程复制数据 ( 异步可以在此阶段做别的事)

    同步IO是程序进行IO操作，在内核向进程复制数据这一阶段，程序被阻塞

    异步IO是内核进行IO操作，当IO完成时，通知程序数据的存储地址，所有在内核向进程复制数据这一阶段，程序可以完成别的操作

16. 

## C++  

1. **右值引用**

   左值： 地址值，可以被赋值

   右值：数据值，不可被赋值，不能被访问地址，即将消亡的数据

   如 int a,b   为左值   a+b为右值

   右值引用可以延长右值的生存周期，窃取其资源而不需要进行拷贝

   例如有个函数返回一个类的对象，那么他先对返回的那个值进行了构造函数，然后接收返回值的那个值调用拷贝构造函数

   如果使用右值引用，就能使用移动构造函数，窃取函数中的返回值对象资源，不需要再调用拷贝构造函数

   之前不能被访问的右值地址现在为接收值的地址了，接收值是左值能被访问

   move可以将左值变为一个右值，move指针，接收值指向原内存地址，原指针失效，move基础值无意义

2. **智能指针**

   c++11后只有shared_ptr、unique_ptr、weak_ptr

   智能指针主要是为了解决内存泄漏的问题，智能指针把普通指针封装成类，然后使用**引用计数**，在引用数为0时，自动释放占用的内存。普通指针可能会有忘记释放或多次释放的问题，智能指针不会

   shared_ptr，多个指针能指向相同的对象，不过可能出现循环引用的问题，循环引用可以由week_ptr解决

   week_ptr，弱指针，指针指向对象，但是对应引用计数不增加，观测资源。**循环引用**是a类有指针指向b，b类有指针指向a（现在新建2个指针  a* p1, b* p2   ,先将p1=nullptr，但是指向a的引用计数为2，现在为1，不会将a析构，p2也一样，所以最后a和b都不会被析构），**解决**：类里的指针用week_ptr

   unique_ptr, 同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）

3. **多态**

   多态分为动态时多态和静态时多态

   静态多态是**函数重载**，在编译时确定调用哪个函数。函数重载是函数相同，形参列表不同( 形参类型 和数量 ) 和返回值类型无关

   动态多态是**虚函数**，在运行时确定调用哪个类的虚函数。一个基类指针指向派生类对象，当对这个指针调用虚函数时，调用的虚函数为派生类的虚函数，这就是动态绑定

   **如何实现**: 每个有虚函数的类都有一个虚函数表指针，指向虚函数表。虚函数表存储着类的所有虚函数位置，派生类继承基类时会先继承基类的虚表然后再对其进行修改

   每个类对象再创建时，编译器会自动加上那个虚表指针，所以使用该对象时，调用的就是该类虚表中的虚函数

4. **构造函数中能调用虚函数，实现多态吗？**

   父类先于子类被构造，当父类中的构造函数被调用时，子类还没有形成，此时子类对于编译器来说是不存在的，所以调用的仍是父类本身的虚函数。

5. **析构函数要不要设置成虚函数**

   需要，因为如果析构函数不为虚函数，那么当删除基类指针指向的派生类对象时，不会触发动态绑定，只会调用基类的析构函数而不会调用派生类的析构函数，造成内存泄漏

6. **数组名和指针的区别**

   数组名相当于含有数组大小的指针常量

   数组名不能++，--

   sizeof(指针) ，显示指针大小，sizeof(数组名) ,显示数组大小

## 数据库

1. **三大范式**

   - 第一范式： 属性不可分割
   - 第二范式： 非主属性完全函数依赖于候选码
   - 第三范式： 非主属性不传递函数依赖于候选码
   - BCNF范式： 主属性完全函数依赖于候选码且不传递函数依赖于候选码

   在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X **完全函数依赖**

   在『Y 不包含于 X，且 X 不函数依赖于 Y』这个前提, 假如 Z 函数依赖于 Y，且 Y 函数依赖于 X，那么我们就称 Z **传递函数依赖**于 X

   设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为**候选码**，简称为**码**。在实际中我们通常可以理解为：**假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。**一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为**主码**）

2. **事务**

   满足ACID的一组操作

   - A  原子性

     事务被视为不可分割的最小单元，事务的所有操作要么都成功要么都失败回滚

     回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

   - C  一致性

     数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

   - I  隔离性

     一个事务所做的修改在最终提交以前，对其它事务是不可见的。

   - D 持久性

     一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。使用重做日志来保证持久性。

3. **并发一致性问题**

   - 丢失数据
   - 脏读
   - 不可重复读
   - 幻读

4. **多版本并发控制**

   

5. 