## 操作系统

1. **进程的状态**

   - 可执行状态   R

   ​	这些进程的PCB被放入可执行队列中

   - 可中断的睡眠状态  S

     等待某某事件发生，PCB在对应事件的等待队列中

   - 不可中断的睡眠状态   D

     内核的某些处理流程是原子操作，是不能中断的

   - 暂停状态  T

     进程收到SIGSTOP，SIGSTP ,SIGTIN, SIGTOU信号后终止

   - 僵尸状态  Z

     进程占用资源被回收，除了PCB，PCB中保存进程的退出码和一些信息

2. 


## 网络

1. **TCP三次握手**

   假设A为客服端，B为服务器端

   - B处于listen状态
   - A向B发送一个请求报文，SYN置为1，ACK为0，序号为x，A进入SYN_SENT状态
   - B向A发送确认报文，SYN置为1，ACK为1，序号为y，确认号为x+1，B进入SYN_RECVD状态
   - A向B发送确认报文，ACK置为1，序号为x+1，确认号y+1,A结束SYN_SENT状态，B结束SYN_RECVD状态
   - 只有第三次握手才能传输数据

2. **为啥需要三次握手**

   防止已失效的请求报文再次到达服务器端，造成服务器端的资源浪费

3. **TCP四次挥手**

   假设A为客户端，B为服务器端

   - A向B发送一个请求断开报文，FIN置为1，序号为 x，A进入FIN_WAIT_1状态
   - B向A发送确认报文，ACK为1，序号为y，确认号为x+1，B进入CLOSE_WAIT状态
   - B向A发送请求断开报文，FIN置为1，序号为z，确认号为x+1,B进入LAST_ACK状态，A进入FIN_WAIT_2状态
   - A向B发送确认报文，序号为x+1，确认号为z+1，A进入TIME_WAIT状态，持续2MSL，B接收LAST_ACK状态

4. **为什么要四次挥手**

   因为TCP是全双工的，客户端和服务器端都要发送请求断开报文和确认报文，当服务器收到请求断开的报文时，服务器可能还有未传输完的数据，等数据传输完后才会发送请求断开报文


5.  **TIME_WAIT的作用**

   - 确保客户端发送的确认报文能到达客户端
   - 确保本次TCP连接中产生的有效报文段都从网络中消失

6. **为什么要2MSL**

   - ACK从A到B最多1MSL，超过这个时间，B会重发FIN
   - B重发的FIN报文最多1MSL到达A

   所以如果B重发FIN报文，在2MSL时间内一定能被A收到

7. **UDP和TCP的区别**

   - UDP是无连接的，支持 广播和多播，TCP是全双工通信的的
   - UDP是尽最大努力交付，但不保证什么，TCP保证数据按序，完整到达
   - UDP首部8字节，TCP首部20字节(不考虑偏移量)
   - UDP面向报文，TCP面向字节流，(数据块数量可以不相等，但是字节数一样)
   - UDP有拥塞控制，TCP没有拥塞控制

8. **TCP如何保证可靠性**

   - 建立连接(标志位)   ：通信前确认通信实体存在
   - 序号和确认号 ：保证数据按序，完整到达
   - 检验和： 保证数据正确
   - 超时重传： 保证丢失的数据能重发
   - 滑动窗口：减轻接收方接收数据的压力大小，流量控制
   - 拥塞控制：减轻网络传输数据的压力大小

9. 

      