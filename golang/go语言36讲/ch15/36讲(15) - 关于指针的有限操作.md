# 36讲(15) - 关于指针的有限操作

<a name="3vOEc"></a>
## 指针
Go 语言标准库中的`unsafe`包。`unsafe`包中有一个类型叫做`Pointer`，也代表了“指针”。<br />`unsafe.Pointer`可以表示任何指向可寻址的值的指针，同时它也是前面提到的指针值和`uintptr`值之间的桥梁。
<a name="0WqbY"></a>
### **你能列举出 Go 语言中的哪些值是不可寻址的吗？**
(右值 ？？)

- 常量的值。
- 基本类型值的字面量。
- 算术操作的结果值。
- 对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，对切片字面量的索引结果值却是可寻址的。
- 对字符串变量的索引表达式和切片表达式的结果值。
- 对字典变量的索引表达式的结果值。
- 函数字面量和方法字面量，以及对它们的调用表达式的结果值。
- 结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。
- 类型转换表达式的结果值。
- 类型断言表达式的结果值。
- 接收表达式的结果值。

**第一个关键词：不可变的**<br />**<br />常量<br />****第二个关键词：临时结果<br />
对**切片字面量的索引结果值是可寻址**的。因为不论怎样，每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的内存地址的。<br />
对**切片字面量的切片结果值为什么却是不可寻址**的？这是因为切片表达式总会返回一个新的切片值，而这个新的切片值在被赋给变量之前属于临时结果。

如果我们把临时结果赋给一个变量，那么它就是可寻址的了。如此一来，取得的指针指向的就是这个变量持有的那个值了。<br />****第三个关键词：不安全的**

通过对**字典类型的变量施加索引表达式，得到的结果值不属于临时结果**，可是，这样的值却是不可寻址的。原因是，字典中的每个键 - 元素对的存储位置都可能会变化，而且这种变化外界是无法感知的。

字典中总会有若干个哈希桶用于均匀地储存键 - 元素对。当满足一定条件时，字典可能会改变哈希桶的数量，并适时地把其中的键 - 元素对搬运到对应的新的哈希桶中。<br />在这种情况下，获取字典中任何元素值的指针都是无意义的，也是**不安全的**。我们不知道什么时候那个元素值会被搬运到何处，也不知道原先的那个内存地址上还会被存放什么别的东西。所以，这样的值就应该是不可寻址的。

<a name="d8ODG"></a>
### 总结

1. **不可变的**值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。
1. 绝大多数被视为**临时结果**的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。
1. 若拿到某值的指针可能会破坏程序的一致性，那么就是**不安全的**，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。
<a name="n334x"></a>
### **不可寻址的值在使用上有哪些限制？**

1. 无法使用取址操作符`&`获取它们的指针了

```go
package main

type Dog struct {
	name string
}

func New(name string) Dog {
	return Dog{name}
}

func (dog *Dog) SetName(name string) {
	dog.name = name
}

func (dog Dog) Name() string {
	return dog.name
}

func main() {
	// 示例1。
	//New("little pig").SetName("monster") // 不能调用不可寻址的值的指针方法。
    /*
    会出现两个报错
    由于New函数的调用结果值是不可寻址的，所以无法对它进行取址操作。
    因此，上边这行链式调用会让编译器报告两个错误，
    一个是果，即：不能在New("little pig")的结果值上调用指针方法。
    一个是因，即：不能取得New("little pig")的地址。
	*/
	// 示例2。
    /*
    Go 语言中的++和--并不属于操作符，而分别是自增语句和自减语句的重要组成部分。
    它还明确了一个很重要的限制，那就是这个表达式的结果值必须是可寻址的。这就使得针对值字面量的表达式几乎都无法被用在这里。
    
    不过这有一个例外，虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。
    
    与之类似的规则还有两个。一个是，在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。
    
    另一个是，在带有range子句的for语句中，在range关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。
    */
	map[string]int{"the": 0, "word": 0, "counter": 0}["word"]++
	map1 := map[string]int{"the": 0, "word": 0, "counter": 0}
	map1["word"]++
}
```
<a name="vxjUQ"></a>
### **怎样通过`unsafe.Pointer`操纵可寻址的值？**
**`unsafe.Pointer`是像`*Dog`类型的值这样的指针值和`uintptr`值之间的桥梁，那么我们怎样利用`unsafe.Pointer`的中转和`uintptr`的底层操作来操纵像`dog`这样的值呢？

[链接](./3.go)