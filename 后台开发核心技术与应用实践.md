## 第4章 编译

编译与连接分为四个步骤 ：

![](./图片/编译与连接.png) 

1. 预处理 （g++ -E hello.cpp  -o  hello.i   ） -E 表示只进行预处理  经过预处理以后，不包含任何宏或头文件，都被展开了 

   2. 编译  (g++ -S hello.i  -o  hello.s )  源代码到汇编代码的转化

      ![](./图片/编译.png)

   3. 汇编 

   4. 连接 主要包括地址和空间分配，符号决议和重定位步骤

![](./图片/连接.png)

链接分为静态链接和动态链接

对函数库的链接是在编译时完成的是静态链接

-c  的编译选项表示只执行到编译

`ar cr libmymath.a sub.o  add.o` 创建静态库 ，库文件以lib开头

`ar tv`可以查看库文件有哪些目标文件

`g++ -o main main.cpp -L. -lmymath`    使用静态库生成main文件

![](./图片/静态库.png)



动态库

`g++ -fPIC -shared -o libmymath.so add.cpp sub.cpp` 生成动态库文件

-fPIC 表示编译为位置独立的代码

执行`g++ -o main main.cpp -L. -lmymath` 不过会报错，提示暂时找不到动态库

动态库路径搜索顺序

- 编译目标代码时指定的动态库搜索路径
- 环境变量LD_LIBRARY_PATH 指定的动态库搜索路径
- 配置文件/etc/ld.so.conf中指定的动态库搜索路径，只需要在该文件中追加一行库所在的完整路径即可如"/root/test/conf/lib"
- 默认的动态库搜索路径/lib
- 默认的动态库搜索路径/usr/lib

所以解决办法

1. 将文件libmymath.so复制到目录/usr/lib中 

   `cp libmymath.so /usr/lib`

2. 修改环境变量LD_LIBRARY_PATH

   `export LD_LIBRARY_PATH=/usr/lib:$LD_LIBRARY_PATH`

   `sudo ldconfig`           ldconfig使修改生效

![](./图片/动态库.png)

**先找动态库，再找静态库**

1. 动态库有利于进程间资源共享

   程序运行时要调用某个动态链接库函数时，操作系统会先查看所有正在运行的程序，看内存中是否有此库函数的拷贝，若有，则共享那一个拷贝，没有才链接载入，节省系统内存空间

2. 将程序升级变得简单

   使用静态库，库发生变化，使用该库的程序要重新编译，使用动态库，只要动态库提供给该程序的接口没变，只要重新用新生成的动态库替换原来的动态库即可

3. 做到链接载入由程序员在程序代码中控制

   函数可以有需求再调入

4. 静态库在编译时将库函数装载到程序中，动态库在运行时装载，程序执行时，静态库更快

**g++和gcc的区别**

1. 后缀为`.c`的文件gcc当做C程序， g++当做C++程序
2. 编译可以用 gcc/g++,链接可以用g++或gcc-lstdc++,因为gcc命令不能自动和c++程序使用的库链接

### makefile的编写

makefile定义一系列规则，指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译等，一个工程的编译规则

`file1.h`

```c++
#ifndef FILE1_H_
#define FILE1_H_
#ifdef __cplusplus
	extern "C" {
        #endif
        void File1Print();
        #ifdef __cplusplus
    }
    #endif
#endif
```

`file1.cpp`

```c++
#include<iostream>
#include "file1.h"
using namespace std;
void File1Print()
{
    cout<<"Print file1******"<<endl;
}
```

`file2.cpp`

```c++
#include <iostream>
#include "file1.h"
using namespace std;
int main()
{
    cout<<"Print file2 "<<endl;
    File1Print();
    return 0;
}
```

`makefile`

```makefile
helloword:file1.o file2.o
	g++ file1.o file2.o -o helloworld

file2.o:file2.cpp
	g++ -c file2.cpp -o file2.o

file1.o:file1.cpp
	g++ -c file1.cpp -o file1.o

clean:
	rm -rf *.o helloworld

```

![](./图片/makefile.png)

```makefile
// 使用变量
XX = g++
CFLAGS = -Wall -O -g   // -O 表示编译时优化 -Wall 输出所有警告  -g 编译debug版本
OBJS = file1.o file2.o

helloworld : $(OBJS)
	$(XX) $(OBJS) -o helloworld
```

```makefile
	
//使用函数
CC = gcc
XX = g++
CFLAGS = -Wall -O -g 
// SOURCES = $(wildcard *.c *.cpp)
wildcard 展开为已经存在的，使用空格分开的 匹配此模式的所有文件列表 ，然后存入SOURCES

// OBJS = $(patsubst %.c,%.o,$(patsubst %.cpp %.o,$(SOURCES)))
patsubst 用于匹配替换， 三个参数  1. 匹配样式 2. 用什么替换 3. 需要被处理的列表
这一句的意思是将SOURCES中所有.c和 .cpp文件 换成.o文件

%.o : %.c 
	$(CC) $(CFLAGS) -c $< -o $@
%.o : %.cpp 
	$(XX) $(CFLAGS) -c $< -o $@
	
// $<  扩展成依赖列表中第一个依赖文件
// $@  拓展成当前规则的目的文件名
// $^  拓展成整个依赖的列表
```

### 目标文件

ELF是一种用于二进制文件，可执行文件，目标代码，共享库和核心转储的标准文件格式

DLF标准的目的是提供一组二进制接口定义，这些接口可以延伸到多操作系统中，从而减少重新编码，编译程序的需要

目标文件有三种类型

- 可重定位的目标文件 (.o)

- 可执行的目标文件 

- 可被共享的目标文件 (.so  )

  动态库发挥作用的步骤 

   	1. 链接器拿它和其他.o文件或 .so文件 作为输入，经链接，生成另外的.so文件或可执行文件
   	2. 在运行时，动态链接器拿它和可执行文件以及别的.so文件一起处理，在linux中创建一个进程映象

左: 可重定位文件格式

右: 可执行文件或可被共享的对象文件的格式

![](./图片/ELF组成.png)

我们可以通过file命令查看文件属于那种ELF文件



通过`readelf -h 文件` 可以查看文件头信息

![](./图片/file.o头信息.png)

![](./图片/helloworld头信息.png)

重定位文件不会有 程序入口点地址，程序入口点是程序真正执行起来时，第一条要运行的指令的地址。重定位文件只是供再链接而已

file1.o 有 15个节头(section) ，没有 program headers

`section`是ELF文件中，用来装载内容数据的最小容器

通过`readelf -S 文件` 查看文件section表

 	1. text section 装载可执行代码
 	2. data  section 装载被初始化数据
 	3. bss section 装载未被初始化数据
 	4. .rec 打头的section装载重定位条目
 	5. symtab 或 dynsym section 装载符号信息
 	6. strtab 或 dynstr section 装载字符串信息
 	7. 其他section 如 满足调试目的， 满足动态链接与加载目的

![](./图片/file1.o的section1.png)

![](./图片/file1.o的section2.png)

暂略。。。。



## 第五章 调试

### strace

strace是通过跟踪系统调用来让开发者知道程序在后台所做事情的工具

`strace -c ./test` 

将进程的所有系统调用做一个统计分析

![](./图片/strace.png)

`-o`可以输出到文件

`strace -c -o test.txt ./test`

`-T`每个系统调用所花费的时间

strace可以追踪已有进程 `strace -p   （进程id)`

### gdb

gdb是调试工具，要在编译时将调试信息加到可执行文件中 `-g`

使用 

1. gdb  program  

   program 为执行文件

2. gdb program core

   core是程序非法执行后的core dump产生文件

3. gdb program  1234

   可以指定服务程序运行时的进程id，我们这里指定他为1234

`test.cpp`

```c++
#include<iostream>
using namespace std;
int func(int n)
{
    int result=0;
    for(int i=1;i<=n;i++)
    {
        result+=i;
    }
    return result;
}
int main()
{

    int arr[10];
    arr[0]=0;
    arr[1]=1;
    for(int i=2;i<10;i++)
    {
        arr[i]=arr[i-1]+arr[i-2];
    }
    cout<<"arr[9]"<<arr[9]<<endl;
    cout<<"func(9)"<<func(9)<<endl;
    return 0;
}

```

|   命令    | 缩写 |                功能                |
| :-------: | :--: | :--------------------------------: |
|   list    |  l   |             查看源代码             |
|   break   |  b   |              设置断点              |
|   info    |      |              查看信息              |
|    run    |  r   |      从头开始运行到第一个断点      |
|  display  | disp |     每次到断点时输出观察的信息     |
|   step    |  s   |         下一步，会进入函数         |
|   next    |  n   |        下一步，不会进入函数        |
|   print   |      |              输出信息              |
| continue  |  c   |          运行到下一个断点          |
|   start   |      |  开始运行，到main函数的第一行为止  |
|   file    |      |              加载文件              |
|   kill    |      |                杀死                |
|   watch   |      | 每次观察的数据改变会停下来然后输出 |
| backtrace |  bt  |           查看函数的堆栈           |
|   quit    |  q   |                退出                |
|  set var  |      |             修改变量值             |

**2.用gdb分析coredump文件**

core是程序非法执行后core  dump后产生的信息，coredump中含有当进程被终止时内存，CPU寄存器和各种函数调用堆栈信息等，程序会提示`Segmentation fault`

查看coredump的**存储路径**`cat  /proc/sys/kernel/core_pattern`

存储默认是当前目标，也可以指定目录，如希望生成到`/data/coredump/core`下，

调用命令`echo "/data/coredump/core" > /proc/sys/kernel/core_pattern`



如果一个程序多次奔溃，那么新生成的core文件会覆盖之前的，我们可以通过修改`kernel`参数，指定内核生成的core文件的文件名

例如要生成名字为`core.filename.pid`的文件

`echo "/data/coredump/core.%e.%p" > /proc/sys/kernel/core_pattern`

这样core文件会带有崩溃的程序名和他的进程id



`/proc/sys/kernel/core_uses_pid`如果被设置成 1 ，那么即使`core_pattern`没设置成%p, 在生成core时也会加上进程id



**产生core文件的条件**

1. 首先确认当前会话的能生成的coredump文件大小 ，

   `ulimit -c` 可以查看文件大小的最大值

   `ulimit -c unlimited`  生成大小不限制   `ulimit -c [size]` ，size单位是blocks，1blocks=512Bytes

   上面只对当前会话有效，如果想系统均有效，则得在`/etc/profile`中 加入一行`ulimit -c unlimited` 

2. 执行对应程序的用户具有对写入core目录的写权限以及有足够的空间

如果能保证这两点，那么就会提示`Segmentation fault(core dumped)`



**产生core文件的原因**

1. 内存访问越界

   - 错误下标

   - 字符串依赖 字符串接收符('\0')来判读字符串是否结束 ,但是字符串没有使用正常的结束符

   - 使用strcpy,strcat,sprintf,strcmp,strcasecmp 时，容易出现字符串读/写 越界情况

     应使用(strncpy , strlcpy,strncat,strlcat ,snprintf ,strncmp, strncasecmp) 等操作

2. 多线程程序使用了线程不安全的函数

3. 多线程读写的数据未加锁保护

4. 非法指针，包括使用空函数  或  随意使用指针转换(内存对齐不同，可能会出现 bus error 导致 core dump)

5. 堆栈溢出

   不使用大的局部变量，因为局部变量存储在栈上，容易造成堆栈溢出

`test.cpp`

```c++
#include<stdio.h>
int main()
{
    int b=1;
    int* a;
    *a=b;
    return 0;
}

```

![](./图片/core的ELF头部.png)

因为core文件没有符号表信息，所以要和可执行文件一起操作

`gdb test core.test.103241`

![](./图片/gdb core.png)

发现是第六步这边出错，可以打印 a和b的值



### top

top能实时显示各个进程的资源占用状况

![](./图片/top1.png)



![](./图片/top.png)

### ps

ps命令列出的是当前在运行的进程的快照，如果想动态显示进程信息，要用top命令

