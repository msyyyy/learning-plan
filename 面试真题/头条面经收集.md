 ##  头条⾯经



### C++题目

1. #### map 和 set 区别与⽤途 .

   答：map和set都是关联容器,是按关键字来保存和访问的，而且都是有序存储

   map保存的是 **key-value**对（关键字 - 值  对）

   ​	 key起到索引的作用， 而value则表示于索引相关联的数据，像字典 

   set 值保存关键字

   ​	set里面每个元素只存有一个key，它支持高效的关键字查询操作，比如检查一个关键字是否在set中或者在 某些文本处理过程中可用set保存想要忽略的单词

   他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn)时间内完成

   由于是他们的底层是红黑树，因此在插入时候他们会默认执行排序操作，且他们key都是唯一的，因此从这个角度看，他们在某种程度上可以实现过滤重复值和排序（默认升序）的功能。

   

   允许重复的都是multi ,  无序存储是 unordered  ( 使用哈希函数组织元素 )

   

2. #### 由上题可能引出红⿊树 

   [红黑树](<http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html>)

3. ####  封装、继承、多态解释⼀下 

   **封装隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性**

   ​	意义在于保护或者防止代码（数据）被我们无意中破坏。

   ​	① 保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==>数据封装。

   ​	②方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==>方法封装。

   **第一: private,public,protected的访问范围:**

   **private**: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问. 
   **protected**: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问
   **public**: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问
   注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数

   **继承提高代码复用性；继承是多态的前提**

   **第二:类的继承后方法属性变化:**

   使用**private继承**,父类的所有方法在子类中变为private; 
   使用**protected继承**,父类的protected和public方法在子类中变为protected,private方法不变; 
   使用**public继承**,父类中的方法属性不发生改变;

   **多态**就是调用同一函数确可能有不同的实现 

   分为 静态多态 （ 函数重载 ） 和动态多态 (虚函数,virtual)

   **函数重载**就是编写好几条函数名字相同但是形参列表( 形参数量和类型 )有所不同的函数

   静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错

   **动态多态是程序运行时**根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。 基类指针指向可以是其派生类，不过这个派生类的虚函数表指针 指向的还是派生类的虚函数表，这样就实现的动态绑定 

   **动态多态的条件：**

   ​	①基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行**重写**。 
   ​	②通过基类对象的指针或者引用调用虚函数。

   **实现动态绑定** : 每个虚函数类有个虚函数表指针 VPTR,指向自己类的虚函数表

   ​	1.先将基类的虚表中的内容拷贝一份 
   ​	2.如果派生类对基类中的虚函数进行重写，使用派生类的虚函数替换相同偏移量位置的基	类虚函数 
   ​	3.如果派生类中新增加自己的虚函数，按照其在派生类中的声明次序，放在上述虚函数之	后 

4. #### 哪些函数不能定义为虚函数？ 
   经检验下面的几个函数都不能定义为虚函数： 
   1）友元函数，它不是类的成员函数 
   2）全局函数 
   3）静态成员函数，它没有this指针 
   3）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）

   

5. #### B+树和B树的区别 

   [b树和b+树](<https://www.cnblogs.com/vincently/p/4526560.html>)

   B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化**大块数据的读和写操作**。B树算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在**数据库**和**文件系统**。

   **B 树**可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。

   - 根节点至少有两个子节点

   - 每个节点有M-1个key，并且以升序排列

   - 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间

   - 其它节点至少有M/2个子节点

下图是一个M=4 阶的B树:

![](./图片/b树.png)

可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。

B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入

**6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4**

![](./图片/b树.gif)

**B+**树是对B树的一种变形树，它与B树的差异在于：

- 有k个子结点的结点必然有k个关键码；
- 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
- 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

**6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4**

![](./图片/b+树.png)

![](./图片/b+树.gif)

**B和B+树的区别在于**，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。

**复杂度**:对于一颗节点为N度为M的子树，查找和插入需要logM-1N ~ logM/2N次比较。这个很好证明，对于度为M的B树，每一个节点的子节点个数为M/2 到 M-1之间，所以树的高度在logM-1N至logM/2N之间。

B+ 树的优点在于：

- 由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。
- B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近

**作用**: 所以B及B+树比较适合与**文件系统的数据结构** 和 做**数据库的索引**


6. #### 什么是⾯向对象 

   **面向对象的三大特性**

   ①封装(隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，	提高复用性和安全性。)

   ②继承(提高代码复用性；继承是多态的前提。)

   ③多态(父类或接口	定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性)

   **五大基本原则**

   ①单一职责原则SRP   (类的功能要单一)

   ②开放封闭原则OCP  (对于拓展是开放的，对于修改是封闭的)

   ③里式替换原则LSP （子类可以替换父类出现在父类能够出现的任何地方）

   ④依赖倒置原则DIP   (具体实现应该依赖于抽象)

   ⑤接口分离原则ISP   (采用多个与特定客户类有关的接口比采用一个通用的接口要好)

   

7. #### 智能指针，unique_ptr,shared_ptr,weak_ptr，能不能返回unique_ptr

   智能指针在C++11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、weak_ptr

   **①shared_ptr**多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁

   - 初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的
   - 拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。
   - get函数获取原始指针
   - 注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存
   - 注意避免循环引用，shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用可以用week_ptr避免。

   **②unique_ptr**“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（不能拷贝也不能赋值、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。

   **unique_ptr指针本身的生命周期**：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。**unique_ptr指针与其所指对象的关系**：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。

   **可以通过移动构造函数(move ) 返回unique_ptr**

   移动构造函数时窃取数据，move可将左值返回一个右值,右值引用可以接管所引用对象

   **③weak_ptr是为了配合shared_ptr而引入的一种智能指针**，因为它不具有普通指针的行为，没有重载operator*和->,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，**它的构造不会引起指针引用计数的增加**。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。

   **智能指针的设计和实现**

   智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。智能指针就是模拟指针动作的类。所有的智能指针都会重载 -> 和 * 操作符。智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限作用域以及临时对象（有限作用域实现）析构函数释放内存。

8. std::move，memcpy与memmove区别

   move左值强制转化为右值引用，继而可以通过右值引用使用该值，窃取了原数据

   memcpy和memmove（）都是C语言中的库函数，在头文件string.h中，作用是拷贝一定长度的内存的内容。

   唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。

9. 段错误，⻚错误 

   **段错误**是由于内存管理单元(MMU)的异常导致的，而该异常通常是由于引用一个未初始化或非法值的指针引起的。如果指针引用一个并不在进程地址空间的地址，便会引发该错误

   通常导致段错误的几个**直接原因**：

   - 引用一个包含非法值的指针
   - 引用一个空指针(常常是由于从函数中返回空指针，未经检查就使用造成的)
   - 数组越界
   - 在未得到正确的权限时进行访问。例如，试图往一个只读的文本段存储值就会引起段错误。
   - 用完了堆或栈空间。

   以发生频率为序，最终可能导致段错误的常见编程错误是：

   - 坏指针值错误
     - 未给指针赋值，就引用指针指向的内存
     - 向库函数传递一个坏指针
     - 对指针指向的内存释放了之后再访问改内存。可以像下面这样做，这样在指针释放之后继续使用该指针的话，至少程序能在终止之前进行core dump。 
       `free(p); p = NULL; `

   - overwrite错误

     - 越过数组边界使用该指针

     - 在动态分配的内存两端之外写入数据，比如，动态分配的内存，用户得到的内存地址p前面包含heap管理的数据结构，如果往地址p前面一点写入值，很可能会破坏heap管理结构。或者在地址p之后写入值，导致heap中下一块内存被破坏。这两种情况都会导致heap内部出错。

     - ```c++
       p = malloc(256);
       p[-1] = 0;
       p[256] = 0
       ```

   - 指针释放引起的错误

     - free同一块内存两次
     - free一块不是使用malloc分配的内存
     - free仍在使用中的内存
     - free一个无效的指针

   **怎么排查这种难缠的错误**

   后来查阅过后才知道充分利用core文件。内核转储的最大好处是能够保存问题发生时的状态。即使问题没有复现，只要获取内核转储，也能调试，通过可执行文件和内核转储，就可以知道进程当时的状态，知道发生问题时的现场，甚至定位到出问题的语句。

   在Ubuntu下，默认是不开启core dump的。

   **开启core文件**

   `ulimit  -c`显示为零，表示core文件的大小限制在0，即不生成core文件。

   设置core file size限制为1G blocks,可在终端输入: `ulimit -c 1073741824`

   或者不限制core file size: `ulimit -c unlimited`

   **通过gdb调试**

   `gdb executable-file core-file`

   以上面往空地址赋值17的例子为例，当在当前目录下生产core文件后，在终端输入

   `gdb ./a.out core`

   而且你可以重新运行并调试该可执行文件，设置断点，查看变量，非常方便。

   **页错误**

   当一个进程要访问一个虚拟页，而这个虚拟页对应的PTE不在页表中， 或者这个PTE在某种方式上禁止访问，比如这页不存在或者访问模式跟这页的访问权限冲突，那么就会触发一个页错误。 页错误由CPU触发，page_fault_handler处理。

10. ⼿写智能指针类，智能指针有关问题 

11. 32位整数-1右移两位是啥 

    正数的左移与右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可。

    负数的右移，就是补码高位补1,然后按位取反加1即可。

### Linux 和 OS 题

1. 线程和进程的区别,创建线程和进程的开销指什么

   **进程**是系统进行资源分配的基本单位，有独立的内存地址空间； 

   **线程**是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，没有单独地址空间，有独立的栈区等。

   在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销，进程需要切换页表；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

   在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

2. 进程间通信

   - 管道（PIPE）
     - 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
       - 优点：可以实现任意关系的进程间的通信
       - 缺点：
         1. 长期存于系统中，使用不当容易出错
         2. 缓冲区有限
     - 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
       - 优点：简单方便
       - 缺点：
         1. 局限于单向通信
         2. 只能创建在它的进程以及其有亲缘关系的进程之间
         3. 缓冲区有限
   - 信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问
     - 优点：可以同步进程
     - 缺点：信号量有限
   - 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
   - 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识
     - 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
     - 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合
   - 共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
     - 优点：无须复制，快捷，信息量大
     - 缺点：
       1. 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题
       2. 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信
   - 套接字（Socket）：可用于不同机器间的进程通信。
     - 优点：
       1. 传输数据为字节级，传输数据可自定义，数据量小效率高
       2. 传输数据时间短，性能高
       3. 适合于客户端和服务器端之间信息实时交互
       4. 可以加密,数据安全性强
     - 缺点：需对传输的数据进行解析，转化成应用级的数据。

3. Linux进程控制

   - 进程地址空间（地址空间）

     虚拟存储器为每个进程提供了独占系统地址空间的假象。尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。有一些"敏感"的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。

   - 进程控制块（PCB）

     进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。

   - 上下文切换

     内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。

4. 操作系统的内存管理

   1. 操作系统负责内存空间的分配与回收

   2. 操作系统要提供某种技术从逻辑上对内存空间进行扩充

      - 交换 ，进程暂时换出内存，动态调度

      - 虚拟内存 ：①多次性( 无需一次性装入内存 )② 对换性 ( 无需在作业运行时常驻内存 ) ③虚拟性(  从逻辑上扩充空间 )   

   3. 提供地址转换，负责程序逻辑地址与物理地址进行转换

5. 分页式的页表放在哪 

   页是逻辑地址空间（虚拟内存空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 512B~8KB。逻辑地址可以解读成页号+地址偏移量（页内地址）

   页表是记录逻辑空间（虚拟内存）中每一页在内存中对应的物理块号。但并非每一页逻辑空间都会实际对应着一个物理块，只有实际驻留在物理内存空间中的页才会对应着物理块。如果有效位为0，说明不在实际内存中，会引发缺页中断

    页表是需要一直驻留在物理内存中的（多级页表除外，多级页表只有第一级在内存中），另外页表的起址和长度存放在 PCB（进程控制块）进程控制结构体中

6. 进程的PCB(进程控制块)⾥还有哪些东西     

   **进程标识符**      **进程当前状态**    **进程优先级**   **CPU现场保护区**                                                                                                                                                                                                                                                                                                                        

7. linux脚本，杀掉包含⼀个关键字的所有进程

   kill 

8. select和epoll的区别 

   - 操作方式及效率：

     select是遍历，需要遍历fd_set每一个比特位（= MAX_CONN），O(n)；poll是遍历，但只遍历到pollfd数组当前已使用的最大下标（≠ MAX_CONN），O(n)；epoll是回调，O(1)。

   - 最大连接数：

     select为1024/2048（一个进程打开的文件数是有限制的）；poll无上限；epoll无上限。

   - fd拷贝： 

     select每次都需要把fd集合从用户态拷贝到内核态；poll每次都需要把fd集合从用户态拷贝到内核态；epoll调用epoll_ctl时拷贝进内核并放到事件表中，但用户进程和内核通过mmap映射共享同一块存储，避免了fd从内核赋值到用户空间。

   - 触发方式

     select是水平触发，epoll可以设置边缘触发

     **水平触发通知：**如果文件描述符上可以非阻塞地执行I/O系统调用，此时认为它已经就绪，触发通知。 同一个事件会被重复通知，如果没处理完

     **举个例子，比如说我们采用epoll水平触发模式监听一个文件描述符的可读，当这个文件可读就绪时，epoll会触发一个通知，然后我们执行一次读取操作，但这次操作我们并没有把该文件描述符的数据全部读取完。当下一次调用epoll监听该文件描述符时，epoll还会再次触发通知，直到该事件被处理完。这就意味着，当epoll触发通知后，我们可以不立即处理该事件，当下次调用epoll监听时，然后会再次向应用程序通告此事件，此时我们再处理也不晚。** 

     **边沿触发通知：**如果文件描述符自上次状态检查以来有了新的I/O活动(比如新的输入)，此时需要触发通知。

     **还是上个例子，如果这次我们采用epoll的边沿触发模式监听一个文件描述符的可读，当可读就绪时，epoll会触发一个通知，如果我们此时不立即处理该事件，当下次再调用epoll监听时，虽然该文件描述符的状态是可读的，但是此时epoll并不会再给应用程序发送通知。因为在边沿触发工作模式下，只有下一个新的I/O事件到来时，才会再次发送通知**

   - 其他：

     select每次内核仅仅是通知有消息到了需要处理，具体是哪一个需要遍历所有的描述符才能找到。epoll不仅通知有I/O到来还可通过callback函数具体定位到活跃的socket，实现伪AIO。

9. 分配内存的时候会发⽣什么事情 

10. 单核CPU，A进程有2个线程，B进程有3个线程，这⼏个线程获得执⾏⼏率分别是多⼤  

   这要看这些进程是用户级线程还是内核支持线程 ， 如果是用户级线程，内核调度仍以进程为单位，感知不到该线程，如果是内核支持线程，那么调度以线程为单位

11. 同步IO和异步IO 

    区别: 同步IO是程序进行IO操作，异步IO是内核进行IO操作，最后返回程序数据存储地址

    IO分两阶段：

    1.数据准备阶段 ( 阻塞 和非阻塞IO区别 )
    2.内核空间复制回用户进程缓冲区阶段( 异步可以在此阶段干别的事 )

    IO由程序接管，写一个读一个，而异步IO，内核把数据全部读完后，返回给程序

12. 死锁及如何避免 

    **原因**

    - 系统资源不足
    - 资源分配不当
    - 进程运行推进顺序不合适

    **产生条件**

    - 互斥。某资源只能被一个进程调用
    - 请求和保持。进程保持了资源，又提出新的资源请求
    - 资源不能剥夺。资源只能等进程使用完自己释放
    - 循环等待。a等待b占用资源，b等待a占用资源

    **预防**

    - 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。
    - 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。
    - 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。
    - 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。
    - 有序资源分配法
    - 银行家算法

13. 代码跑起来需要⼏个内存块？各个地⽅存的什么？ 

14. 堆和栈？线程共享的是那⼀部分是哪⼀部分？

15. ⼿写LRU( 最近最久未使用算法 )

    链表，用了的放开头

16. ⼀个进程，有10个⼦进程，那么⼀个⼦进程fork⼀个⼦进程，那么这个⼦进程有多少个进程。 

17. 如何查找出现频率最⾼的100个ip地址(shell) 16. Linux io模型(select, poll, epoll的区别，⽔平触发和边缘触发的区别)

18. 虚拟内存

    虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换

    虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

    CPU 通过一个**虚拟地址（virtual address,VA）**来访问主存，这个虚拟地址在被送到主存之前会先转换成一个物理地址。将虚拟地址转换成物理地址的任务叫做**地址翻译（address translation）**。

    地址翻译需要 CPU 硬件和操作系统之间的配合。 CPU 芯片上叫做**内存管理单元（Menory Management Unit, MMU）**的专用硬件，利用存放在主存中的查询页表来动态翻译虚拟地址，该表的内容由操作系统管理。

19. 分页和分段

    分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

### NetWork题⽬ 

1. 从输⼊⽹址到关闭窗口发⽣了什么 

   答：输入网址相当于发送http请求，会先通过dns将域名转化为IP，然后向目标IP发送http请求报文，http是用tcp作为运输协议的，所以会经过三次握手。 

   - 建立起客户机和服务器连接。
   - 建立连接后，客户机发送一个请求给服务器。
   - 服务器收到请求给予响应信息。
   - 客户端浏览器将返回的内容解析并呈现，断开连接

   http连接有两种，一种是非持续连接 ，一种是持续连接

   非持续连接，每次进行一次HTTP通信都会建立新的TCP连接 

   持续连接，建立一次tcp就能进行多次http，不过可能会长时间占用服务器资源，降低吞吐量

   比如 页面上有图片，那么得到的html文件会有对图片的引用，我们需要对每个图片进行http请求，非持续就得建立多个tcp连接，而持续只需要建立一个

   而且http是无状态协议，如果我们得用cookie标识用户，Cookie是客户端保持状态的方法

   cookie有四个组件

   - http请求报文中的cookie首部行
   - http响应报文中的cookie首部行
   - 客户端系统中保存一个cookie，由浏览器管理
   - 服务器后端数据库存储一个cookie

   

2. tcp 连接之前具体发⽣了什么,TCP如何保障可靠性传输 

   **三次握手**

   - 第一次：客户端发含SYN位，SEQ_NUM = S的包到服务器。（客 -> SYN_SEND）
   - 第二次：服务器发含ACK，SYN位且ACK_NUM = S + 1，SEQ_NUM = P的包到客户机。（服 -> SYN_RECV）
   - 第三次：客户机发送含ACK位，ACK_NUM = P + 1的包到服务器。（客 -> ESTABLISH，服 -> ESTABLISH）

   **保证可靠性**

   - 建立连接（标志位）：通信前确认通信实体存在。
   - 序号机制（序号、确认号）：确保了数据是按序、完整到达。
   - 数据校验（校验和）：CRC校验全部数据。
   - 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。
   - 窗口机制（窗口）：提供流量控制，避免过量发送。
   - 拥塞控制：同上。

3. 四次挥⼿，为什么是四次 

   TCP是双工的，所以发送方和接收方都需要FIN和ACK。服务器会先把没传完的数据先传完CLOSE_WAIT状态

4. 三次握⼿，为什么是三次,TCP连接的本质,为什么要有 time_wait

   因为防止已经失效的TCP连接请求又到达服务器端，造成服务器端资源浪费

   TIME_WAIT是为了确保服务器端接收到客户端发送的确认ACK

5. TCP 的拥塞控制 

   慢启动，拥塞避免，快速恢复三个步骤

   **慢启动**是将拥塞窗口cwnd设置为1MSS，然后每收到一个确认报文都增长1个MSS，所以慢启动是指数增长的。慢启动有三个停止的方法 ① 存在由超时指示的丢包，cwdn置为1，重新开始慢启动

   ② cwnd超过慢启动阈值，进入拥塞避免③ 由3个冗余ACK指示的丢包，先快速重传，然后进入快速恢复，cwnd变为原来一半，进入拥塞避免

   **拥塞避免**是慢启动有一个满启动阈值，当拥塞窗口大于这个阈值时，进入拥塞避免，拥塞避免是线性增长，每个RTT( 连接返回时间 )增长1MSS

   **快速恢复** 拥塞窗口变为原来一半，进入拥塞避免

6. 讲⼀下 CDN 

   CDN是内容分发网，管理分布在多个地理位置上的服务器，在服务器上存储内容。用户请求内容时，会从信号最好的服务器拉取，如果该服务器没有用户请求的资源，会从其他服务器上拉取，然后存储其副本，他会删除不经常请求的内容

   **CDN通过DNS来截取和重定向请求**，使用户获得最好的体验。这时权威dns服务器不是返回IP而是返回CDN域的主机名，通过这样进入CDN专用的DNS基础设施，最后返回信号最好的服务器IP

   **至于怎么选择那个最优的服务器**,通过集群选择策略，最简单的策略是选取地理上最近的，还有就是CND周期性对集群和客户之间的时延和丢包性能进行实时测量

   不过因为建造基础设施成本很高，也有CDN-P2P流式系统，会向有这个视频副本的对等方请求该视频的块，不过和p2p下载 不同最先请求的是即将播放的块确保连续播放。如果流量不够还是得启动CND连接

7. P2P文件分发

   因为服务器得想每个客户端发送相同的文件，对服务器压力很大。而p2p允许每个对等方向任何其他对等方重新分发它已经收到的该文件的任何内容。通过追踪器( 注册，周期通知追踪器自己还在)知道那些对等方还在集合中。

   一个内容会分成很多块，**请求哪些块**： 最稀缺的那些，可以维持所有块数量大致相等

   **回应哪些主机的请求**： 对提供给他数据的速度最快的给其优先权，确认4个，然后每过一段时间随机选一个主机给予数据。(可以让对等方都以趋向于找到彼此的协调速率上载)

8. cookie⽤来做什么的 

   答：因为http是无状态协议，所以需要cookie来标识用户

9. http协议是什么，和tcp什么关系？ 

   答：http协议是超文本传输协议 ，http协议是依赖于tcp协议实现的，选择tcp协议为他的支撑运输协议

    **请求报文**

   请求行 ( 方法 ， uri ，版本 ) 方法 : get ，head ，post ，put，delete

   首部行

   ![](./图片/http请求报文.png)

   **响应报文**

   状态行 ( 版本 状态码  短语)

   首部行

   ![](./图片/http响应报文.png)

   状态码： 

   - 200：成功。
   - 301：内容已经移动。
   - 400：请求不能被服务器理解。
   - 403：无权访问该文件。
   - 404：不能找到请求文件。
   - 500：服务器内部错误。
   - 501：服务器不支持请求的方法。
   - 505：服务器不支持请求的版本。

10. UDP了解过？和TCP区别？建不建连接是指的什么 

  UDP是无连接的，可以广播和多播，不保证数据可靠传输，首部8字节，无拥塞控制，面向报文

  TCP是点到点的全双工连接，保证数据可靠，按序到达，首部20字节，有拥塞控制，面向字节流

  建立连接双方可以进行进行数据交换，且数据保证准确

11. osi七层模型

    ![](./图片/计算机经网络体系结构.png)

12. 滑动窗口和TCP流量控制 

    滑动窗口大小一般取决于接收方返回TCP报文段中的窗口大小字段控制，而且滑动窗口必须小于序列空间大小的一半，不然分不清是之前的无效数据还是新数据

    - 目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。
    - TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。
      - 发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。
      - 接收窗：用来标记可以接收的数据大小。
    - TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。
    - 发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。

13. 如果滑动窗口为0，则怎么办

    当被告知接收窗口为0后，发送方不能再发送了，它会定期的发送窗口探寻，直到窗口不为0，或者定时器过期，关闭TCP连接

14. DNS解析过程 

    区分 协议，域名和端口号，然后在浏览器缓冲中找是否有对应IP

    主机询问本地dns服务器是否存在该域名，如果不存在，那么本地服务器会访问根dns，根dns返回顶级dns的IP，本地dns访问顶级dns，返回权威dns的IP，本地dns访问权威dns，dns返回对应IP，本地将IP返回给主机

15. ⽹络层都有哪些协议，区别是什么，各⾃是做什么的 .

    - IP（网际协议）是为计算机网络相互连接进行通信而设计的协议。
    - ARP（地址解析协议）ARP 实现由 IP 地址得到 MAC 地址
      - ARP只为在同一个子网上的主机和路由器接口解析IP地址 ( 广播 )
      - 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。
    - ICMP（网际控制报文协议）被主机和路由器用来彼此沟通网络层的信息
      - ICMP 报文分为差错报告报文和询问报文
      - ![](./图片/ICMP种类.png)
      - 应用 ping   「主要用来测试两台主机之间的连通性 」和 Traceroute 「用来跟踪一个分组从源点到终点的路径」
      - Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。
      - Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。
        - 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
        - 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
        - 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
        - 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。
    - IGMP（网际组管理协议）

    

16. 数据链路层都有哪些协议，区别是什么，各⾃是做什么的

    CSMA/CD 表示载波监听多点接入 / 碰撞检测。

    PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。

17. tcp状态

    - CLOSED：初始状态。
    - LISTEN：服务器处于监听状态。
    - SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。
    - SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。
    - ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。
    - FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。
    - CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。
    - FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。
    - LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。
    - TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。

18. 



### 算法题 

1. ⼆叉树先序遍历，层次遍历实现 
2. ⽤栈实现队列
3. 包含 max 函数的栈 
4. ⼿写代码，滑动窗口最⼤值（单调栈,leetcode 239） 
5. 智⼒题：岛上每个⼈都带着帽⼦，颜⾊为红⾊或⽩⾊，不能相互问，当知道⾃⼰帽⼦的颜⾊时就可以离开。某 天⼀个外来⼈来了，说了句：“红⾊的帽⼦⾄少有⼀顶。”，问之后岛上⼈们的离开情况(出现2次)
6. str_to_int(string s) 
7. 给⼀个数组，定义X为某个区间的最小值乘上这个区间内所有元素的和，求最⼤的X。如数组为3 1 6 4 5，则最 ⼤的X=4*（6+4+5）=60
8. 求数组的中位数。数组由⼀个升序数组翻转形成，如1 2 3 4 5 6 7可以从5处翻转，形成5 6 7 1 2 3 4，求5 6 7 1 2 3 4的中位数。要求时间复杂度低于O(n)。
9. ⼀个单链表，奇数位置升序，偶数位置降序，将这个链表调整为整体升序，写出代码
10. ⼿撕代码：按层次遍历⼆叉树 
11. ⼿撕代码：按层次遍历⼆叉树（不完全⼆叉树）节点为null的需要输出null 
12. ⼿撕代码：求⼆叉树的两个节点的最近共同⽗节点 
13. ⼿撕代码：问题同上，空间复杂度O(1) 
14. ⼿撕代码：常规⼆叉树树节点求最近共同⽗节点 
15. 多个不定⻓有序数组合并 
16. 背包算法 
17. ⼿写两个有序数组，找第K⼤，我就挂在这题，我⽤的时归并的思路查找，刚刚搜了⼀下，这题是LeetCode原 题，更好的解法是⼆分查找。⾯完不到两分钟，HR打电话过来告诉我三⾯⾯的不好，到此结束。 
18. 算法 12322121343434 1232212134343*4 必须插⼊五个星号，每个数字必须在0-600之间，有⼏种插⼊⽅法 
19. ⼀个上T的⽂本⽂件，⾥⾯很多字符串并且⽤空格分隔，找到不同的字符串数量
20. url反转 例如将www.baidu.com转化成www.udiab.moc 
21. ⼿写strcat函数和strcmp函数 
22.  ⼿上⼀副牌12345....M，先放1张（1）到桌⼦上，然后把下⼀张（2）放到最后（M后）；再放⼀张（3）到桌 ⼦上，然后把下⼀张（4）放到最后......求⼿上没有牌的时候桌⼦上的牌的顺序。（我选择⽤递归去做，⾯试官 说可以不⽤递归，但是我个⼈感觉递归解释⽐较清楚） 
23. 字符串去驼峰处理 例如aba输出b，abcba输出c......分析时间复杂度
24. 给定⼀个排序链表，删除所有重复的元素，使得每个元素只出现⼀次 
25. 给定⼀个⼆叉树，原地将它展开为链表
26. 给定⼀棵⼆叉树，想象⾃⼰站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 
27. ⼿写快排
28. ⼿写堆排 
29. 已知出栈序列求所有的⼊栈序列（这题很有意思，当时只是写了列出所有的可能，后来想到这题和已知⼊栈序 列求所有出栈序列是⼀样的） 
30. 排序算法的稳定性 
31. 写代码，字符串中的最⻓重复⼦串 
32. leetcode-329 
33. 最⻓公共⼦串 
34. leetcode-76 
35. ⼿写算法题）第⼆道题，调整⼀棵⼆叉树，调整后，要求所有节点的右⼦树的最⼤值⼤于左⼦树的最⼤值。
36.  第三道题变态难：⽤两种积木，2X1型，1X1型，摆满n⾏m列，有多少种摆法。考虑2⾏m列有多少种摆法，再 算n⾏m列，有了这个提⽰好做多啦幸福
37. 设计⼀个可以满⾜⾼效率获取第k⼤和前k个⼤的元素的数据结构 
38. 解释下哈希表的设计 以及哈希冲突的解决等， rehash的具体过程
39. ⼿写求两个链表第⼀个交叉节点 